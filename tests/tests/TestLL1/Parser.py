__copyright__ = """
If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""
import typing
from functools import wraps
from CoCoRuntime.parser import Parser
from CoCoRuntime.scanner import Position
from .Scanner import ScannerEnum


def _generateSet() -> typing.Tuple[typing.Tuple[bool, ...], ...]:
	T = True
	x = False
	return ((T, x, x, x, x, x, x, x, x, x, x),)


class MyParser(Parser):
	__slots__ = ()

	@wraps(Parser.__init__)
	def __init__(self, *args, **kwargs):
		"""This ctor is mandatory, don't delete it: otherwise self.__class__.ENUM will be None"""
		super().__init__(*args, **kwargs)

	ENUM = ScannerEnum
	__main_production_name__ = "Test"
	__EOF_sym__ = ScannerEnum.EOF_SYM

	def pragmas(self) -> None:
		pass

	def Test(self) -> None:
		self.A()
		self.E()
		self.C()
		self.G()
		self.H()
		self.I()
		self.J()

	def A(self) -> None:
		if self.la.kind == self.__class__.ENUM.a_Sym:
			self.Get()
		elif self.la.kind == self.__class__.ENUM.a_Sym or self.la.kind == self.__class__.ENUM.b_Sym or self.la.kind == self.__class__.ENUM.c_Sym:
			self.B()
		else:
			self.SynErr(11)

	def E(self) -> None:
		if self.la.kind == self.__class__.ENUM.e_Sym or self.la.kind == self.__class__.ENUM.f_Sym:
			self.F()
		elif self.la.kind == self.__class__.ENUM.e_Sym:
			pass
		else:
			self.SynErr(12)
		self.Expect(self.__class__.ENUM.e_Sym)

	def C(self) -> None:
		while self.la.kind == self.__class__.ENUM.a_Sym:
			self.Get()
		if self.la.kind == self.__class__.ENUM.d_Sym:
			self.D()
		self.B()

	def G(self) -> None:
		if self.la.kind == self.__class__.ENUM.a_Sym or self.la.kind == self.__class__.ENUM.b_Sym:
			if eee:
				if self.la.kind == self.__class__.ENUM.a_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.b_Sym:
					self.Get()
				else:
					self.SynErr(13)
			else:
				self.Get()
		self.Expect(self.__class__.ENUM.a_Sym)

	def H(self) -> None:
		if self.la.kind == self.__class__.ENUM.a_Sym:
			self.Get()
		if hhh:
			self.Get()
		if hhh:
			self.Get()
		self.Expect(self.__class__.ENUM.a_Sym)

	def I(self) -> None:
		while self.la.kind == self.__class__.ENUM.a_Sym:
			self.Get()
		if iii:
			if self.la.kind == self.__class__.ENUM.a_Sym:
				self.Get()
			elif self.la.kind == self.__class__.ENUM.b_Sym:
				self.Get()
			else:
				self.SynErr(14)
		elif self.la.kind == self.__class__.ENUM.b_Sym:
			self.Get()
		else:
			self.SynErr(15)

	def J(self) -> None:
		while aaa:
			self.Get()
		while self.la.kind == self.__class__.ENUM.a_Sym or self.la.kind == self.__class__.ENUM.b_Sym:
			if eee:
				if self.la.kind == self.__class__.ENUM.a_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.b_Sym:
					self.Get()
				else:
					self.SynErr(16)
			else:
				self.Get()
		self.Expect(self.__class__.ENUM.a_Sym)

	def B(self) -> None:
		while self.la.kind == self.__class__.ENUM.b_Sym:
			self.Get()
		if self.la.kind == self.__class__.ENUM.c_Sym:
			self.Get()
		elif self.la.kind == self.__class__.ENUM.a_Sym:
			pass
		else:
			self.SynErr(17)
		self.Expect(self.__class__.ENUM.a_Sym)

	def D(self) -> None:
		self.Expect(self.__class__.ENUM.d_Sym)
		if self.la.kind == self.__class__.ENUM.b_Sym:
			self.Get()

	def F(self) -> None:
		if self.la.kind == self.__class__.ENUM.f_Sym:
			self.Get()

	set = _generateSet()
	errorMessages = "EOF expected", "a expected", "b expected", "c expected", "d expected", "e expected", "f expected", "g expected", "h expected", "i expected", "??? expected", "invalid A", "invalid E", "invalid G", "invalid I", "invalid I", "invalid J", "invalid B"
