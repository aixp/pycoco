"""This is a scanner."""
__copyright__ = """
If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""
import typing
import array
from enum import IntEnum
from functools import wraps
from CoCoRuntime.scanner import Buffer, Scanner, prepareLiteralsTable


class ScannerEnum(IntEnum):
	eofSym = 0
	noSym = 2
	maxT = 2
	_EOF = 0
	EOF_SYM = 0
	_ident = 1
	ident_Sym = 1
	NOT_SYM = 2


class MyScanner(Scanner):
	__slots__ = ()

	@wraps(Scanner.__init__)
	def __init__(self, *args, **kwargs):
		"""This ctor is mandatory, don't delete it: otherwise self.__class__.ENUM will be None"""
		super().__init__(*args, **kwargs)

	ENUM = ScannerEnum
	charSetSize = 256
	maxT = 2
	start = array.array("b", (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1))

	def initialization(self) -> None:
		pass

	ignores = frozenset((32,))

	def casing(self) -> None:
		pass

	def Comment0(self) -> bool:
		level = 1
		line0 = self.line
		lineStart0 = self.lineStart
		self.NextCh()
		if self.ch == "*":
			self.NextCh()
			while True:
				if self.ch == "*":
					self.NextCh()
					if self.ch == ")":
						level -= 1
						if level == 0:
							self.oldEols = self.line - line0
							self.NextCh()
							return True
						self.NextCh()
				elif self.ch == "(":
					self.NextCh()
					if self.ch == "*":
						level += 1
						self.NextCh()
				elif self.ch == Buffer.EOF:
					return False
				else:
					self.NextCh()
		else:
			if self.ch == Scanner.EOL:
				self.line -= 1
				self.lineStart = lineStart0
			self.pos = self.pos - 2
			self.buffer.setPos(self.pos + 1)
			self.NextCh()
		return False

	def Comment1(self) -> bool:
		level = 1
		line0 = self.line
		lineStart0 = self.lineStart
		self.NextCh()
		if self.ch == "*":
			self.NextCh()
			while True:
				if self.ch == "*":
					self.NextCh()
					if self.ch == "/":
						level -= 1
						if level == 0:
							self.oldEols = self.line - line0
							self.NextCh()
							return True
						self.NextCh()
				elif self.ch == Buffer.EOF:
					return False
				else:
					self.NextCh()
		else:
			if self.ch == Scanner.EOL:
				self.line -= 1
				self.lineStart = lineStart0
			self.pos = self.pos - 2
			self.buffer.setPos(self.pos + 1)
			self.NextCh()
		return False

	def Comment2(self) -> bool:
		level = 1
		line0 = self.line
		lineStart0 = self.lineStart
		self.NextCh()
		if self.ch == "/":
			self.NextCh()
			while True:
				if ord(self.ch) == 13:
					self.NextCh()
					if ord(self.ch) == 10:
						level -= 1
						if level == 0:
							self.oldEols = self.line - line0
							self.NextCh()
							return True
						self.NextCh()
				elif self.ch == Buffer.EOF:
					return False
				else:
					self.NextCh()
		else:
			if self.ch == Scanner.EOL:
				self.line -= 1
				self.lineStart = lineStart0
			self.pos = self.pos - 2
			self.buffer.setPos(self.pos + 1)
			self.NextCh()
		return False

	literalsTable = prepareLiteralsTable({})

	def CheckLiteral(self) -> ScannerEnum:
		return self.__class__.literalsTable.get(self.t.val, self.t.kind)

	def scan1(self) -> bool:
		return self.ch == "(" and self.Comment0() or self.ch == "/" and self.Comment1() or self.ch == "/" and self.Comment2()

	def scan2(self, buf: str) -> str:
		buf += str(self.ch)
		self.NextCh()
		return buf

	def scan3(self, state: int, apx: int, buf: str) -> typing.Tuple[typing.Optional[int], ScannerEnum, int, str]:
		if state == 1:
			if "0" <= self.ch <= "9" or "A" <= self.ch <= "Z" or "a" <= self.ch <= "z":
				buf += str(self.ch)
				self.NextCh()
				return 1, self.t.kind, apx, buf
			return None, self.__class__.ENUM.ident_Sym, apx, buf
		return state, self.t.kind, apx, buf
