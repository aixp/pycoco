__copyright__ = """
If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""
import typing
from functools import wraps
from CoCoRuntime.parser import Parser
from CoCoRuntime.scanner import Position
from .Scanner import ScannerEnum


def _generateSet() -> typing.Tuple[typing.Tuple[bool, ...], ...]:
	T = True
	x = False
	return (T, x, x, x, x, x), (x, T, T, x, T, T)


class MyParser(Parser):
	__slots__ = ()

	@wraps(Parser.__init__)
	def __init__(self, *args, **kwargs):
		"""This ctor is mandatory, don't delete it: otherwise self.__class__.ENUM will be None"""
		super().__init__(*args, **kwargs)

	ENUM = ScannerEnum
	__main_production_name__ = "Test"
	__EOF_sym__ = ScannerEnum.EOF_SYM

	def pragmas(self) -> None:
		pass

	def Test(self) -> None:
		if self.la.kind == self.__class__.ENUM.a_Sym:
			self.A()
			self.B()
			self.C()
			self.D()
			self.E()
			self.F()
			self.G()
			self.H()
		elif self.la.kind == self.__class__.ENUM.EOF_SYM or self.la.kind == self.__class__.ENUM.b_Sym or self.la.kind == self.__class__.ENUM.c_Sym:
			self.I()
		else:
			self.SynErr(6)

	def A(self) -> None:
		self.Expect(self.__class__.ENUM.a_Sym)
		while self.la.kind == self.__class__.ENUM.b_Sym:
			if true:
				self.Get()
				self.Expect(self.__class__.ENUM.c_Sym)
			self.Get()
		self.Expect(self.__class__.ENUM.c_Sym)

	def B(self) -> None:
		if self.la.kind == self.__class__.ENUM.a_Sym:
			self.Get()
		elif eee:
			self.Get()
		elif self.la.kind == self.__class__.ENUM.b_Sym:
			pass
		else:
			self.SynErr(7)
		self.Expect(self.__class__.ENUM.b_Sym)

	def C(self) -> None:
		if true:
			self.Get()
			self.Expect(self.__class__.ENUM.b_Sym)
		elif self.la.kind == self.__class__.ENUM.a_Sym:
			self.Get()
		else:
			self.SynErr(8)

	def D(self) -> None:
		while self.la.kind == self.__class__.ENUM.a_Sym:
			if true:
				self.Get()
			else:
				self.Get()
				self.Expect(self.__class__.ENUM.b_Sym)
		self.Expect(self.__class__.ENUM.c_Sym)

	def E(self) -> None:
		if self.la.kind == self.__class__.ENUM.a_Sym:
			self.Get()
		elif self.la.kind == self.__class__.ENUM.c_Sym or self.la.kind == self.__class__.ENUM.d_Sym:
			if self.la.kind == self.__class__.ENUM.c_Sym:
				if true:
					self.Get()
				else:
					self.Get()
					self.Expect(self.__class__.ENUM.b_Sym)
		elif self.la.kind == self.__class__.ENUM.b_Sym:
			self.Get()
		else:
			self.SynErr(9)
		self.Expect(self.__class__.ENUM.d_Sym)

	def F(self) -> None:
		while self.StartOf(1):
			if true:
				if self.la.kind == self.__class__.ENUM.a_Sym:
					self.Get()
				self.Expect(self.__class__.ENUM.b_Sym)
			elif self.la.kind == self.__class__.ENUM.d_Sym or self.la.kind == self.__class__.ENUM.NOT_SYM:
				self.Get()
			else:
				self.Get()
		self.Expect(self.__class__.ENUM.c_Sym)

	def G(self) -> None:
		while aaa:
			self.Get()
		while bbb:
			if eee:
				if self.la.kind == self.__class__.ENUM.a_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.b_Sym:
					self.Get()
				else:
					self.SynErr(10)
			elif self.la.kind == self.__class__.ENUM.b_Sym:
				self.Get()
			else:
				self.SynErr(11)
		self.Expect(self.__class__.ENUM.a_Sym)

	def H(self) -> None:
		while aaa:
			self.Get()
		while self.la.kind == self.__class__.ENUM.a_Sym or self.la.kind == self.__class__.ENUM.b_Sym:
			if eee:
				if self.la.kind == self.__class__.ENUM.a_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.b_Sym:
					self.Get()
				else:
					self.SynErr(12)
			else:
				self.Get()
		self.Expect(self.__class__.ENUM.c_Sym)

	def I(self) -> None:
		if aaa:
			if self.la.kind == self.__class__.ENUM.b_Sym:
				self.Get()
		elif self.la.kind == self.__class__.ENUM.EOF_SYM or self.la.kind == self.__class__.ENUM.c_Sym:
			while self.la.kind == self.__class__.ENUM.c_Sym:
				self.Get()
		else:
			self.SynErr(13)

	set = _generateSet()
	errorMessages = "EOF expected", '"a" expected', '"b" expected', '"c" expected', '"d" expected', "??? expected", "invalid Test", "invalid B", "invalid C", "invalid E", "invalid G", "invalid G", "invalid H", "invalid I"
