"""Parser of CoCoPy files (dialect of CoCo/R)."""

__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code

import ast
from enum import IntEnum

from .actions import CharAct, State, TransitionCode
from .charUtils import Unescape
from .CharClass import charSetSize
from .CLI import parseArgs
from .Core import Comment, Graph
from .nodes import Node, NodeAny, NodeCharClass, NodeEmpty, NodeNonTerminal, NodeResolverExpr, NodeSemAct, NodeSynchronization, NodeTerminal, NodeWeakTerminal
from .Preamble import Preamble
from .symbols import Symbol, SymbolTokensKinds, SymNonTerminal, SymPragma, SymTerminal

# pylint:disable=too-many-branches,too-many-statements,too-many-public-methods,too-many-lines,too-many-boolean-expressions

class OurTokenKind(IntEnum):
	id = 0
	str = 1


class ArgObj:
	__slots__ = "name", "type"

	def __init__(self, name: ast.Name = None, type: ast.Name = None) -> None:
		self.name = name
		self.type = type


COMPILER Coco
#-------------------------------------------------------------------------

CHARACTERS
	letter	= "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_".
	digit		= "0123456789".
	cr		= '\r'.
	lf		= '\n'.
	tab		= '\t'.
	printable = '\x20' .. '\x7e'.
	alchar	= '\x00' .. '\xff' .
	stringCh	= ANY - '"' - '\\' - cr - lf.
	charCh	= ANY - '\'' - '\\' - cr - lf.
	hex		= "0123456789abcdef".
	space = ' '.

TOKENS
	ident		= letter { letter | digit }.
	number		= digit { digit }.
	string		= '"' {stringCh | '\\' printable} '"' |
				  "'" { charCh | '\\' printable} "'"  .
	badString	= '"' {stringCh | '\\' printable}(cr | lf) |
				  "'" {charCh | '\\' printable }(cr | lf) .

PRAGMAS
	ddtSym	= '$' { digit | letter }.
	(.
		self.la.val = "-" + str(self.la.val[1:])
		parseArgs([self.la.val])
	.)

COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO lf

IGNORE space + cr + lf + tab

/*-------------------------------------------------------------------------*/

PRODUCTIONS

Coco
	(.
		g	= Graph(self.controller.dfa)  # pylint:disable=no-member
		g1	= Graph(self.controller.dfa)  # pylint:disable=no-member
		g2	= Graph(self.controller.dfa)  # pylint:disable=no-member
		s	= set()
	.)
=
	(.
		beg = self.token.pos
	.)

	pythonSource<out preamble>
		(.
			self.controller.preamble = preamble  # pylint:disable=no-member
		.)

	/*[ Imports<out self.pg.usingPos> ]*/
	"COMPILER"
		(.
			self.controller.genScanner = True  # pylint:disable=no-member
			self.controller.table.ignored = None
		.)
	ident
		(.
			self.controller.gramName = self.token.val
			beg = self.la.pos
		.)
	{ ANY }						(.	self.controller.table.semDeclPos = Position(self.scanner.buffer, beg, self.la.pos - beg, 0)	.)
	[
		"IGNORECASE"
			(.
				self.controller.dfa.ignoreCase = True  # pylint:disable=no-member
			.)
	]
	[ "CHARACTERS"	{ SetDecl } ]
	[ "TOKENS"	{ TokenDecl<SymTerminal> } ]
	[ "NAMES"	{ NameDecl } ]
	[ "PRAGMAS"	{ TokenDecl<SymPragma> } ]
	{	"COMMENTS"				(.	nested = False	.)
		"FROM" TokenExpr<out g1>
		"TO" TokenExpr<out g2>
		[
			"NESTED"			(.	nested = True	.)
		]						(.	self.controller.dfa.commentsListHead = Comment(self.controller.dfa.commentsListHead, self.controller.dfa.charClassStorage, g1.l, g2.l, nested, self.controller.errors)	.)
	}
	{
		"IGNORE" Set<out s>
			(.
				if self.controller.table.ignored is None:
					self.controller.table.ignored = set()
				self.controller.table.ignored |= s # set union
			.)
	}

	SYNC
	"PRODUCTIONS"
		(.
			if self.controller.genScanner:  # pylint:disable=no-member
				self.controller.dfa.MakeDeterministic(self.controller.errors)  # pylint:disable=no-member
			self.controller.table.DeleteNodes()
		.)
	{
		ident
			(.
				sym = self.controller.table.findSymbol(self.token.val)
				undef =(sym is None)
				if undef:
					sym = SymNonTerminal(self.controller.table, self.token.val, self.token.line, self.controller.errors)
				else:
					if isinstance(sym, SymNonTerminal):
						if sym.graph is not None:
							self.SemErr("name declared twice")
					else:
						self.SemErr("this symbol kind not allowed on left side of production")
					sym.line = self.token.line
				noAttrs = not sym.attrs
				sym.attrs = []
				noRet = not sym.returnAttrs
				sym.returnAttrs = []
			.)
		[ AttrDecl<sym> ]
			(.
				if not undef:
					if noAttrs != (not sym.attrs) or noRet != (not sym.returnAttrs):
						self.SemErr("attribute mismatch between declaration and use of this symbol")
			.)
		[ SemText<out sym.semPos> ]
		WEAK '='
			Expression<out g>
			(.
				sym.graph = g.l
				Graph.Finish(g)
			.)
			WEAK '.'
	}
	"END"
	ident
		(.
			self.controller.grammarName1 = self.token.val  # pylint:disable=no-member
		.)
	'.'
.

pythonSource <out Preamble preamble> =
	(.
		beg = self.la.pos
		linesToStartOfGrammar = None
		try:
			ast.parse(self.scanner.buffer.buf[beg:], mode="exec")
		except SyntaxError as synErr:
			linesToStartOfGrammar = synErr.lineno - 1

		if linesToStartOfGrammar is None:
			raise ValueError("Cannot determine end of python preamble, looks like the whole file is a valid python source")

		if linesToStartOfGrammar < 0:
			linesToStartOfGrammar = 0

		sourceStartLine = self.la.line
		sourceEndLine = sourceStartLine + linesToStartOfGrammar

		end = beg
	.)
	{
		ANY
			(.
				if self.la.line >= sourceEndLine:
					end = self.la.pos
					break
			.)
	}
		(.
			while end and self.scanner.buffer.buf[end] != "\n":
				end -= 1

			preamble = Preamble(ast.parse(self.scanner.buffer.buf[beg : end], mode="exec").body)
		.)
.


/*------------------------------------------------------------------------------------*/

SetDecl
=
	ident
		(.
			name = self.token.val
			c = self.controller.dfa.charClassStorage.Find(name)
			if c is not None:
				self.SemErr("name declared twice")
		.)
	'=' Set<out s>
		(.
			if len(s) == 0:
				self.SemErr("character set must not be empty")
			c = self.controller.dfa.charClassStorage.spawn(name, s)  # pylint:disable=no-member
		.)
	'.'
.

/*------------------------------------------------------------------------------------*/

Set<out typing.Union[int, str] s>
=
	SimSet<out s>
	{
		'+' SimSet<out s2>		(.	s |= s2	.)
	|
		'-' SimSet<out s2>		(.	s -= s2	.)
	}
.

/*------------------------------------------------------------------------------------*/

SimSet<out typing.Set[typing.Union[int, str]] s>
	(.
		n1 = 0
		n2 = 0
		name = ''
	.)
=
	(.
		s = set()
		mx = charSetSize
	.)
	(
		ident
			(.
				c = self.controller.dfa.charClassStorage.Find(self.token.val)
				if c is None:
					self.SemErr("undefined name")
				else:
					s |= c.set
			.)
	| String<out name>
		(
			(.
				for c in name:
					if self.controller.dfa.ignoreCase:  # pylint:disable=no-member
						s.add(ord(c.lower()))
					else:
						s.add(ord(c))
			.)
		|
			(.
				if len(name) != 1 or ord(name[0]) > mx - 1:
					self.SemErr("unacceptable character value")
				else:
					n1 = ord(name[0]) % mx
				if self.controller.dfa.ignoreCase and ord("A") <= n1 <= ord("Z"):  # pylint:disable=no-member
					n1 += 32
			.)
			".."
			(
				String<out name>
					(.
						if len(name) != 1 or ord(name[0]) > mx - 1:
							self.SemErr("unacceptable character value")
						else:
							n2 = ord(name[0]) % mx
						if self.controller.dfa.ignoreCase and ord("A") <= n2 <= ord("Z"):  # pylint:disable=no-member
							n2 += 32
					.)
			|
				SingleChar<out n2, mx>
			)
				(.
					for i in range(n1, n2 + 1):
						s.add(i)
				.)
		)
	|
		SingleChar<out n1, mx>			(.	s.add(n1)	.)
		[
			".."
			(
				String<out name>
					(.	if len(name) != 1 or ord(name[0]) > mx - 1:
							self.SemErr("unacceptable character value")
						else:
							n2 = ord(name[0]) % mx
						if self.controller.dfa.ignoreCase and ord("A") <= n2 <= ord("Z"):  # pylint:disable=no-member
							n2 += 32
					.)
				| SingleChar<out n2, mx>
			)
				(.
					for i in range(n1, n2):
						s.add(i)
				.)
		]

	| "ANY"
		(.
			s = set()
			for num in range(0, charSetSize):
				s.add(num)
			s.add("ANYCHAR")
		.)
	)
.

/*--------------------------------------------------------------------------------------*/

SingleChar<out int n, int mx>
=
	(.	n = 0	.)
	"CHR" "("
	number
		(.
			n = int(self.token.val)
			if n > mx - 1:
				self.SemErr("unacceptable character value")
			if self.controller.dfa.ignoreCase and ord("A") <= n <= ord("Z"):  # pylint:disable=no-member
				n += 32
			n %= mx
		.)
	")"
.

/*--------------------------------------------------------------------------------------*/

String<out str name>
=
	string
	(.
		name = self.token.val
		name = Unescape(name[1:-1], self.errors)  # pylint:disable=no-member
	.)
.

/*------------------------------------------------------------------------------------*/

TokenDecl<typing.Type[Symbol] typ>
=
	Sym<out s>
		(.
			name, ourKind = s
			sym = self.controller.table.findSymbol(name)
			if sym is not None:
				self.SemErr("name declared twice")
			else:
				sym = typ(self.controller.table, name, self.token.line, self.controller.errors)
				sym.tokenKind = SymbolTokensKinds.fixedToken
			self.tokenString = None
		.)
	SYNC
	(
		'=' TokenExpr<out g>
		'.'
			(.
				if ourKind == OurTokenKind.str:
					self.SemErr("a literal must not be declared with a structure")
				Graph.Finish(g)
				if self.tokenString is None or self.tokenString == self.noString:
					self.controller.dfa.ConvertToStates(g.l, sym, self.controller.errors)  # pylint:disable=no-member
				else:  # TokenExpr is a single string
					if self.controller.table.literals.get(self.tokenString) is not None:
						self.SemErr("token string declared twice")
					self.controller.table.literals[self.tokenString] = sym
					self.controller.dfa.MatchLiteral(self.tokenString, sym, self.controller.errors)  # pylint:disable=no-member
			.)
	|
		(.
			if ourKind == OurTokenKind.id:
				self.controller.genScanner = False  # pylint:disable=no-member
			else:
				self.controller.dfa.MatchLiteral(sym.name, sym, self.controller.errors)  # pylint:disable=no-member
		.)
	)
	[
		SemText<out sym.semPos>
			(.
				if typ is not SymPragma:
					self.SemErr("semantic action not allowed here")
			.)
	]
.

/*------------------------------------------------------------------------------------*/

SingleArgDecl <out ArgObj argObj, SymNonTerminal sym>
=
	(.
		typ = ""
		squareBracesCount = 0
		singleQuotesCount = 0
		doubleQuotesCount = 0
	.)
	{
		(
			ANY
				(.
					if self.la.kind in (self.__class__.ENUM.greater_Sym, self.__class__.ENUM.comma_Sym):
						if squareBracesCount == 0 and singleQuotesCount & 1 == 0 and doubleQuotesCount & 1 == 0:
							if self.token.kind == self.__class__.ENUM.ident_Sym:
								name = ast.parse(self.token.val, mode="eval")
								if typ:
									typ = ast.parse(typ, mode="eval")
									if isinstance(typ, ast.Expression):
										typ = typ.body
								break
							raise ValueError("Token name must be an identifier:", self.token.val)
				.)
		|
			'['  (. squareBracesCount += 1 .)
		|
			']'  (. squareBracesCount -= 1 .)
		|
			'\''  (. singleQuotesCount += 1 .)
		|
			'"'  (. doubleQuotesCount += 1 .)
		)
			(.
				typ += self.token.val
			.)
	}
	(. argObj = ArgObj(name, typ) .)
.



AttrDecl<Symbol sym>
=
	 '<'
	(
		('^' | "out")
		SingleArgDecl<out outArg, sym>	(. sym.returnAttrs.append(outArg) .)
		(
			'>'
		|
			{
				','
				SingleArgDecl<out inArg, sym>	(. sym.attrs.append(inArg) .)
			}
			'>'
		)
	|
		[
			SingleArgDecl<out inArg, sym>	(. sym.attrs.append(inArg) .)
			{
				','
				SingleArgDecl<out inArg, sym>	(. sym.attrs.append(inArg) .)
			}
		]
		'>'
	)
|
	'<.'
	(
		('^' | "out")
		SingleArgDecl<out outArg, sym>	(. sym.returnAttrs.append(outArg) .)
		(
			'.>'
		|
			{
				','
				SingleArgDecl<out inArg, sym>	(. sym.attrs.append(inArg) .)
			}
			'.>'
		)
	|
		{
			ANY
			|
			badString		(.	self.SemErr("bad string in attributes d")	.)
		}
		'.>'
	)
.

/*------------------------------------------------------------------------------------*/

Expression<out Graph g>
=
	Term<out g>
		(.
			assert g.l is not None
			first = True
		.)
	{
		WEAK '|'
		Term<out g2>
			(.
				if first:
					g.MakeFirstAlt(self.controller.table)
					first = False
				g.MakeAlternative(self.controller.table, g2)
			.)
	}
.

/*------------------------------------------------------------------------------------*/

Term<out Graph g>
	(.
		rslv = None
		g = None
	.)
=
	(
		[
			(.	rslv = NodeResolverExpr(self.controller.table, self.la.line)	.)
			Resolver<out rslv.pos>
				(.
					g = Graph(self.controller.dfa, rslv)  # pylint:disable=no-member
					assert g.l is not None
				.)
		]
		Factor<out g2>
			(.
				if rslv is not None:
					g.MakeSequence(g2)
				else:
					g = g2
					assert g.l is not None
			.)
		{
			Factor<out g2>		(.	g.MakeSequence(g2)	.)
		}
	|
		(.
			g = Graph(self.controller.dfa, NodeEmpty(self.controller.table))  # pylint:disable=no-member
			assert g.l is not None
		.)
	)
		(.
			if g is None:  # invalid start of Term
				g = Graph(self.controller.dfa, NodeEmpty(self.controller.table))  # pylint:disable=no-member
				assert g.l is not None
		.)
.

/*------------------------------------------------------------------------------------*/

Factor<out Graph g>
	(.
		weak = False
		g = None
	.)
=
	(
		[
			"WEAK"					(.	weak = True	.)
		]
		Sym<out s>
			(.
				name,ourKind = s
				sym = self.controller.table.findSymbol(name)
				if sym is None and ourKind == OurTokenKind.str:
					sym = self.controller.table.literals.get(name)
				undef =(sym is None)
				if undef:
					if ourKind == OurTokenKind.id:
						sym = SymNonTerminal(self.controller.table, name, 0, self.controller.errors)  # forward nt
					elif self.controller.genScanner:  # pylint:disable=no-member
						sym = SymTerminal(self.controller.table, name, self.token.line, self.controller.errors)
						self.controller.dfa.MatchLiteral(sym.name, sym, self.controller.errors)  # pylint:disable=no-member
					else:  # undefined string in production
						self.SemErr("undefined string in production")
						sym = self.controller.table.eofSy  # dummy

				if isinstance(sym, SymTerminal):
					ctor = NodeTerminal
				elif isinstance(sym, SymNonTerminal):
					ctor = NodeNonTerminal
				else:
					self.SemErr("this symbol kind is not allowed in a production")

				if weak:
					if isinstance(sym, SymTerminal):
						ctor = NodeWeakTerminal
					else:
						self.SemErr("only terminals may be weak")

				p = ctor(self.controller.table, sym, self.token.line)
				g = Graph(self.controller.dfa, p)  # pylint:disable=no-member
			.)
		[ Attribs<p>
			(.
				if ourKind != OurTokenKind.id:
					self.SemErr("a literal must not have attributes")
			.)
		]
			(.
				if undef:
					sym.attrs = p.attrs  # dummy
					sym.returnAttrs = p.returnAttrs  # AH - dummy
				elif bool(p.attrs) != bool(sym.attrs) or bool(p.returnAttrs) != bool(sym.returnAttrs):
					self.SemErr("attribute mismatch between declaration and use of this symbol:" + repr(p.attrs) + ", " + repr(sym.attrs) + ", " + repr(p.returnAttrs) + ", " + repr(sym.returnAttrs))
			.)
	|	'(' Expression<out g> ')'		(.	assert g.l is not None	.)
	|	'[' Expression<out g> ']'
			(.
				g.MakeOption(self.controller.table)
				assert g.l is not None
			.)
	|	'{' Expression<out g> '}'
			(.
				g.MakeIteration(self.controller.table)
				assert g.l is not None
			.)
	|	SemText<out pos>
			(.
				p = NodeSemAct(self.controller.table, 0)
				p.pos = pos
				g = Graph(self.controller.dfa, p)  # pylint:disable=no-member
				assert g.l is not None
			.)
	|	"ANY"
			(.
				p = NodeAny(self.controller.table, 0)  # p.set is set in self.controller.table.SetupAnys
				assert p is not None
				g = Graph(self.controller.dfa, p)  # pylint:disable=no-member
				assert g.l is not None
			.)
	|	"SYNC"
		(.
			p = NodeSynchronization(self.controller.table, 0)
			assert p is not None
			g = Graph(self.controller.dfa, p)  # pylint:disable=no-member
			assert g.l is not None
		.)
	)
		(.
			if g is None:   # invalid start of Factor
				g = Graph(self.controller.dfa, NodeEmpty(self.controller.table))  # pylint:disable=no-member
				assert g.l is not None
		.)
.

/*------------------------------------------------------------------------------------*/

Resolver<out Position pos>
=
	"IF" "("
		(.
			beg = self.la.pos
			col = self.la.col
		.)
	Condition	(.	pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col)	.)
.

/*------------------------------------------------------------------------------------*/

Condition = { "(" Condition | ANY } ")" .

/*------------------------------------------------------------------------------------*/

TokenExpr<out Graph g>
=
	TokenTerm<out g>				(.	first = True	.)
	{
		WEAK '|'
		TokenTerm<out g2>
			(.
				if first:
					g.MakeFirstAlt(self.controller.table)
					first = False
				g.MakeAlternative(self.controller.table, g2)
			.)
	}
.

/*------------------------------------------------------------------------------------*/

TokenTerm<out Graph g>
=
	TokenFactor<out g>
	{
		TokenFactor<out g2>			(.	g.MakeSequence(g2)	.)
	}
	[
		"CONTEXT" '('
		TokenExpr<out g2>
			(.
				g.SetContextTrans(g2.l)
				g.MakeSequence(g2)
			.)
		')'
	]
.

/*------------------------------------------------------------------------------------*/

TokenFactor<out Graph g>
=
	(.	g = None.)
(
	Sym<out s>
		(.
			name, ourKind = s
			if ourKind == OurTokenKind.id:
				c = self.controller.dfa.charClassStorage.Find(name)
				if c is None:
					c = self.controller.table.findSymbol(name)
					if c is None:
						self.SemErr("undefined name " + name)
						c = self.controller.dfa.charClassStorage.spawn(name, set())
				p = NodeCharClass(self.controller.table, c.n, 0)
				g = Graph(self.controller.dfa, p)  # pylint:disable=no-member
				self.tokenString = self.noString
			else:  # str
				g = Graph.StrToGraph(self.controller, name, self.errors)  # pylint:disable=no-member
				if self.tokenString is None:
					self.tokenString = name
				else:
					self.tokenString = self.noString
		.)
|
	'(' TokenExpr<out g> ')'
|
	'[' TokenExpr<out g> ']'		(.	g.MakeOption(self.controller.table)	.)
|
	'{' TokenExpr<out g> '}'		(.	g.MakeIteration(self.controller.table)	.)
)
	(.
		if g is None:    # invalid start of TokenFactor
			g = Graph(self.controller.dfa, NodeEmpty(self.controller.table))  # pylint:disable=no-member
			assert g.l is not None
	.)
.

/*------------------------------------------------------------------------------------*/

Sym<out typing.Tuple[str, OurTokenKind] s>
=
	(.
		name = "???"
		ourKind = OurTokenKind.id
	.)
(
	ident
		(.
			ourKind = OurTokenKind.id
			name = self.token.val
		.)
	|
	string
		(.
			ourKind = OurTokenKind.str
			name = '"' + self.token.val[1:-1] + '"'
			if self.controller.dfa.ignoreCase:  # pylint:disable=no-member
				name = name.lower()
			if name.find(" ") >= 0:
				self.SemErr("literal tokens must not contain blanks")
		.)
)	(.	s = name, ourKind	.)
.

/*------------------------------------------------------------------------------------*/

Attribs<Node n>
=
	'<'
	(
		('^' | "out")				(.	beg = self.la.pos	.)
		{
			ANY
		|
			badString				(.	self.SemErr("bad string in attributes e")	.)
		}
			(.
				#print("self.la", self.la.kind, self.la.val)
				if n.returnAttrs is None:
					n.returnAttrs = []
					n.returnAttrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.la.pos), mode="eval")))
			.)
		(
			'>'
		|
			','
				(.
					beg = self.la.pos
					col = self.la.col
				.)
			{
				ANY
			|
				badString				(.	self.SemErr("bad string in attributes f")	.)
			}
			'>'
				(.
					if self.token.pos > beg:
						#print("self.token", self.token.kind, self.token.val)
						if n.attrs is None:
							n.attrs = []
							n.attrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.token.pos), mode="eval")))
				.)
		)
	|
		(.
			beg = self.la.pos
			col = self.la.col
		.)
		{
			ANY
		|
			badString					(.	self.SemErr("bad string in attributes g")	.)
		}
		'>'
			(.
				if self.token.pos > beg:
					#print("self.token", self.token.kind, self.token.val)
					if n.attrs is None:
						n.attrs = []
						n.attrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.token.pos), mode="eval")))
			.)
	)
	|
	"<."
	(
		('^' | "out")				(.	beg = self.la.pos	.)
		{
			ANY
		|
			badString				(.	self.SemErr("bad string in attributes h")	.)
		}
		(.
			#print("self.la", self.la.kind, self.la.val)
			if n.returnAttrs is None:
				n.returnAttrs = []
				n.returnAttrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.la.pos), mode="eval")))
		.)
		(
			".>"
		|
			','
				(.
					beg = self.la.pos
					col = self.la.col
				.)
			{
				ANY
				|
				badString			(.	self.SemErr("bad string in attributes i")	.)
			}
			".>"
				(.
					if self.token.pos > beg:
						#print("self.token", self.token.kind, self.token.val)
						if n.attrs is None:
							n.attrs = []
							n.attrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.token.pos), mode="eval")))
				.)
		)
	|
		(.
			beg = self.la.pos
			col = self.la.col
		.)
		{
			ANY
			|
			badString			(.	self.SemErr("bad string in attributes j")	.)
		}
		".>"
			(.
				if self.token.pos > beg:
					#print("self.token", self.token.kind, self.token.val)
					if n.attrs is None:
						n.attrs = []
					n.attrs.append(ArgObj(self.scanner.buffer.getString(beg, self.token.pos)))
			.)
	).

/*------------------------------------------------------------------------------------*/

SemText<out Position pos>
=
	"(."
		(.
			beg = self.la.pos
			col = self.la.col
		.)
	{
		ANY
	|
		badString				(.	self.SemErr("bad string in semantic action")	.)
	|
		"(."					(.	self.SemErr("missing end of previous semantic action")	.)
	}
	".)"						(.	pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col)	.)
.

/*------------------------------------------------------------------------------------*/

NameDecl
=
	ident						(.	alias = self.token.val	.)
	"="
	(ident | string)			(.	self.controller.table.NewName(alias, self.token.val, self.controller.errors)	.)
	"."
.

/*------------------------------------------------------------------------------------*/
/*
Imports<out Position pos>
	(.
		beg = None
		pos = None
	.)
=
	[
		'from'				(.	beg = self.token.pos	.)
		ident { '.' ident }
	]
	'import'
		(.
			if beg is None:
				beg = self.token.pos
		.)
	(
		(
			ident
			{ '.' ident }
			{
				',' ident
				{ '.' ident }
			}
		)
	|
		(
			'(' ident
			{
				'.' ident
			}
			{
				',' ident
				{ '.' ident }
			}
			')'
		)
	|
		'*'
	)

	{
		[
			'from'
			ident
			{
				'.'
				ident
			}
		]
		'import'
		(
			(
				ident
				{ '.' ident }
				{
					',' ident
					{ '.' ident }
				}
			)
		|
			(
				'(' ident
				{ '.' ident }
				{
					',' ident
					{ '.' ident }
				}
				')'
			)
		)
	}
		(.
			end = self.la.pos
			pos = Position(self.scanner.buffer, beg, end - beg, 0)
		.)
.
*/

END Coco.
