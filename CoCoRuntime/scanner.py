"""Scanner.py -- The ATG file scanner."""

__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code

import typing
from abc import ABC, abstractmethod

try:
	import datrie

	def prepareLiteralsTable(m: typing.Mapping[str, "ScannerEnum"]) -> typing.Mapping[str, "ScannerEnum"]:
		alphabet = set()
		for k in m.keys():
			alphabet |= set(k)
		t = datrie.BaseTrie(alphabet=alphabet)
		t.update(m)
		return t

except ImportError:

	def prepareLiteralsTable(m: typing.Mapping[str, "ScannerEnum"]) -> typing.Mapping[str, "ScannerEnum"]:
		return m


class Token:
	__slots__ = ("kind", "pos", "col", "line", "val", "next")

	def __init__(self) -> None:
		self.kind = 0  # token kind
		self.pos = 0  # token position in the source text (starting at 0)
		self.col = 0  # token column (starting at 0)
		self.line = 0  # token line (starting at 1)
		self.val = ""  # token value
		self.next = None  # AW 2003-03-07 Tokens are kept in linked list


class Position:
	"""position of source code stretch (e.g. semantic action, resolver expressions)"""

	__slots__ = ("buf", "beg", "len", "col")

	def __init__(self, buf: "Buffer", beg: int, len: int, col: int) -> None:
		assert isinstance(buf, Buffer)
		assert isinstance(beg, int)
		assert isinstance(len, int)
		assert isinstance(col, int)

		self.buf = buf
		self.beg = beg  # start relative to the beginning of the file
		self.len = len  # length of stretch
		self.col = col  # column number of start position

	def getSubstring(self) -> str:
		return self.buf.readPosition(self)

	def __repr__(self):
		return self.__class__.__name__ + "<" + ", ".join(repr(getattr(k)) for k in __class__.__slots__[1:]) + ">"


class Buffer:
	__slots__ = ("buf", "bufLen", "pos", "lines")
	EOF = "\u0100"  # 256

	def __init__(self, s: str) -> None:
		self.buf = s
		self.bufLen = len(s)
		self.pos = 0
		self.lines = s.splitlines(True)

	def Read(self) -> str:
		if self.pos < self.bufLen:
			result = chr(ord(self.buf[self.pos]) & 0xFF)  # mask out sign bits
			self.pos += 1
			return result

		return self.__class__.EOF

	def ReadChars(self, numBytes: int = 1) -> str:
		result = self.buf[self.pos : self.pos + numBytes]
		self.pos += numBytes
		return result

	def Peek(self):
		if self.pos < self.bufLen:
			return chr(ord(self.buf[self.pos]) & 0xFF)  # mask out sign bits

		return self.__class__.EOF

	def getString(self, beg: int, end: int) -> str:
		s = ""
		oldPos = self.getPos()
		self.setPos(beg)
		while beg < end:
			s += self.Read()
			beg += 1
		self.setPos(oldPos)
		return s

	def getPos(self) -> int:
		return self.pos

	def setPos(self, value: int) -> None:
		if value < 0:
			self.pos = 0
		elif value >= self.bufLen:
			self.pos = self.bufLen
		else:
			self.pos = value

	def readPosition(self, pos: Position) -> str:
		assert isinstance(pos, Position)
		self.setPos(pos.beg)
		return self.ReadChars(pos.len)

	def __iter__(self):
		return iter(self.lines)

	def __repr__(self):
		return self.__class__.__name__ + "<" + str(len(self.buf)) + ", " + ", ".join(repr(getattr(k)) for k in __class__.__slots__[1:]) + ">"


class Scanner(ABC):
	__slots__ = ("buffer", "ch", "pos", "line", "lineStart", "oldEols", "ignore", "tokens", "t", "pt")
	ENUM = None  # type: typing.Type["ScannerEnum"]

	EOL = "\n"
	start = None  # type: typing.Collection[int]
	finalStates = None  # type: typing.Mapping[int, "ScannerEnum"], key is state number, value is `self.t.kind` after transition
	literalsTable = None  # type: typing.Mapping[str, "ScannerEnum"], maps keywords to tokens

	@abstractmethod
	def initialization(self) -> None:
		raise NotImplementedError

	@abstractmethod
	def casing(self) -> None:
		pass

	def __init__(self, s: str) -> None:
		self.buffer = Buffer(str(s))  # the buffer instance

		self.ch = "\0"  # current input character
		self.pos = -1  # position of current character
		self.line = 1  # line number of current character
		self.lineStart = 0  # start position of current line
		self.oldEols = 0  # EOLs that appeared in a comment;
		self.NextCh()
		self.ignore = set()  # set of characters to be ignored by the scanner
		self.initialization()

		# fill token list
		self.tokens = Token()  # the complete input token stream
		node = self.tokens

		node.next = self.NextToken()
		node = node.next
		while node.kind != self.__class__.ENUM.eofSym:
			node.next = self.NextToken()
			node = node.next

		node.next = node
		node.val = "EOF"
		self.t = self.tokens  # current token
		self.pt = self.tokens  # current peek token

	def NextCh(self) -> None:
		if self.oldEols > 0:
			self.ch = Scanner.EOL
			self.oldEols -= 1
		else:
			self.ch = self.buffer.Read()
			self.pos += 1
			# replace isolated '\r' by '\n' in order to make
			# eol handling uniform across Windows, Unix and Mac
			if (self.ch == "\r") and (self.buffer.Peek() != "\n"):
				self.ch = Scanner.EOL
			if self.ch == Scanner.EOL:
				self.line += 1
				self.lineStart = self.pos + 1
		self.casing()

	@abstractmethod
	def CheckLiteral(self) -> "ScannerEnum":
		raise NotImplementedError

	@abstractmethod
	def scan1(self) -> bool:
		raise NotImplementedError

	@abstractmethod
	def scan2(self, buf: str) -> str:
		raise NotImplementedError

	@abstractmethod
	def scan3(self, state: int, apx: int, buf: str) -> typing.Tuple[typing.Optional[int], "ScannerEnum", int, str]:
		"""Returns a tuple, which elements are:
			* new state or None if the state is final one
			* new token kind
			* new (or old, if unchanged) value of `apx`
			* new (or old) value of `buf`
		"""
		raise NotImplementedError

	def NextToken(self) -> Token:
		while ord(self.ch) in self.ignores:
			self.NextCh()

		apx = 0

		if self.scan1():
			return self.NextToken()

		self.t = Token()
		self.t.pos = self.pos
		self.t.col = self.pos - self.lineStart + 1
		self.t.line = self.line
		state = self.start[ord(self.ch)]
		buf = ""
		buf = self.scan2(buf)

		while state is not None:
			if state == -1:
				self.t.kind = self.__class__.ENUM.eofSym  # NextCh already done
				state = None
			elif state == 0:
				self.t.kind = self.__class__.ENUM.noSym  # NextCh already done
				state = None
			else:
				if state < len(self.__class__.finalStates):
					self.t.kind = self.finalStates[state]
					state = None
				else:
					state, self.t.kind, apx, buf = self.scan3(state, apx, buf)

		self.t.val = buf
		return self.t

	def Scan(self) -> Token:
		self.t = self.t.next
		self.pt = self.t.next
		return self.t

	def Peek(self):
		self.pt = self.pt.next
		while self.pt.kind > self.ENUM.maxT:
			self.pt = self.pt.next

		return self.pt

	def ResetPeek(self):
		self.pt = self.t
