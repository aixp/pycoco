"""self.py -- Error handling routines"""

__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code

import sys
import typing
from io import StringIO
from pathlib import Path

from .scanner import Buffer


class ErrorRec:
	__slots__ = ("line", "col", "num", "str")

	def __init__(self, line: int, col: int, s: str) -> None:
		assert isinstance(line, int), line
		assert isinstance(col, int), col
		assert isinstance(s, str), repr(s)

		self.line = line
		self.col = col
		self.num = 0
		self.str = s


class Errors:
	errMsgFormat = "file %(file)s : (%(line)d, %(col)d) %(text)s\n"
	minErrDist = 2
	errDist = minErrDist
	# A function with prototype: f( errorNum=None ) where errorNum is a
	# predefined error number.  f returns a tuple, ( line, column, message )
	# such that line and column refer to the location in the
	# source file most recently parsed.  message is the error
	# message corresponging to errorNum.

	def __init__(self) -> None:
		self.errors = []
		self.warnings = []
		self.mergedList = None  # PrintWriter
		self.listName = ""

	def storeError(self, line: int, col: int, s: str) -> None:
		self.errors.append(ErrorRec(line, col, s))

	def storeWarning(self, line: int, col: int, s: str) -> None:
		self.warnings.append(ErrorRec(line, col, s))

	@property
	def count(self) -> int:
		return len(self.errors)

	def Warn(self, line: int, col: int, errMsg: str) -> None:
		self.storeWarning(line, col, errMsg)

	@staticmethod
	def Exception(errMsg):
		print(errMsg)
		sys.exit(1)

	@staticmethod
	def printMsg(fileName: str, line: int, column: int, msg: str) -> None:
		vals = {"file": fileName, "line": line, "col": column, "text": msg}
		sys.stdout.write(__class__.errMsgFormat % vals)

	@staticmethod
	def display(s, e, resBuff):
		resBuff.write("**** ")
		for c in range(1, e.col):
			if s[c - 1] == "\t":
				resBuff.write("\t")
			else:
				resBuff.write(" ")
		resBuff.write("^ " + e.str + "\n")

	def Summarize(self, sourceBuffer: Buffer) -> str:
		# Initialize the line iterator
		srcLineIter = iter(sourceBuffer)
		srcLineStr = next(srcLineIter, None)
		srcLineNum = 1

		resBuff = StringIO()

		# Initialize the error iterator
		errIter = iter(sorted(self.errors, key=lambda v: (v.line, v.col)))
		warnIter = iter(sorted(self.warnings, key=lambda v: (v.line, v.col)))

		errRec = next(errIter, None)
		warnRec = next(warnIter, None)

		while errRec and errRec.line < 0:
			print(errRec.str, file=resBuff)
			errRec = next(errIter, None)

		while warnRec and warnRec.line < 0:
			print(warnRec.str, file=resBuff)
			warnRec = next(warnIter, None)

		while errRec or warnRec:
			# Advance to the source line of the next error
			while srcLineStr is not None and (errRec is None or srcLineNum < errRec.line) and (warnRec is None or srcLineNum < warnRec.line):
				srcLineStr = next(srcLineIter, None)
				srcLineNum += 1

			resBuff.write("%4d %s\n" % (srcLineNum, srcLineStr))
			# Write out all errors for the current source line
			while errRec and errRec.line == srcLineNum:
				self.display(srcLineStr, errRec, resBuff)
				errRec = next(errIter, None)

			while warnRec and warnRec.line == srcLineNum:
				self.display(srcLineStr, warnRec, resBuff)
				warnRec = next(warnIter, None)

			errRec = next(errIter, None)
			warnRec = next(warnIter, None)

		resBuff.write("%d errors and %d warnings detected\n" % (self.count, len(self.warnings)))
		if self.count > 0:
			resBuff.write("see " + self.listName + "\n")
		return resBuff.getvalue()
