"""Parser of CoCoPy files (dialect of CoCo/R).

This is a scanner."""
__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""
import array
import typing
from enum import IntEnum
from functools import wraps

from CoCoRuntime.scanner import Buffer, Scanner, prepareLiteralsTable


class ScannerEnum(IntEnum):
	eofSym = 0
	noSym = 47
	maxT = 47
	_EOF = 0
	EOF_SYM = 0
	_ident = 1
	ident_Sym = 1
	_number = 2
	number_Sym = 2
	_string = 3
	string_Sym = 3
	_badString = 4
	badString_Sym = 4
	COMPILER_Sym = 5
	IGNORECASE_Sym = 6
	CHARACTERS_Sym = 7
	TOKENS_Sym = 8
	NAMES_Sym = 9
	PRAGMAS_Sym = 10
	COMMENTS_Sym = 11
	FROM_Sym = 12
	TO_Sym = 13
	NESTED_Sym = 14
	IGNORE_Sym = 15
	PRODUCTIONS_Sym = 16
	equal_Sym = 17
	point_Sym = 18
	END_Sym = 19
	plus_Sym = 20
	minus_Sym = 21
	pointpoint_Sym = 22
	ANY_Sym = 23
	CHR_Sym = 24
	lparen_Sym = 25
	rparen_Sym = 26
	lbrack_Sym = 27
	rbrack_Sym = 28
	squote_Sym = 29
	dquote_Sym = 30
	less_Sym = 31
	uparrow_Sym = 32
	out_Sym = 33
	greater_Sym = 34
	comma_Sym = 35
	lesspoint_Sym = 36
	pointgreater_Sym = 37
	bar_Sym = 38
	WEAK_Sym = 39
	lbrace_Sym = 40
	rbrace_Sym = 41
	SYNC_Sym = 42
	IF_Sym = 43
	CONTEXT_Sym = 44
	lparenpoint_Sym = 45
	pointrparen_Sym = 46
	NOT_SYM = 47
	_ddtSym = 48
	ddtSym_Sym = 48


class MyScanner(Scanner):
	__slots__ = ()

	@wraps(Scanner.__init__)
	def __init__(self, *args, **kwargs):
		"""This ctor is mandatory, don't delete it: otherwise self.__class__.ENUM will be None"""
		super().__init__(*args, **kwargs)

	ENUM = ScannerEnum
	charSetSize = 256
	maxT = 47
	start = array.array("b", (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, 0, 22, 0, 0, 28, 30, 7, 0, 4, 12, 5, 29, 0, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 0, 0, 31, 3, 11, 0, 0, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 8, 0, 9, 10, 0, 0, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 16, 15, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1))

	def initialization(self) -> None:
		pass

	ignores = frozenset((9, 10, 13, 32))

	def casing(self) -> None:
		pass

	def Comment0(self) -> bool:
		level = 1
		line0 = self.line
		lineStart0 = self.lineStart
		self.NextCh()
		if self.ch == "/":
			self.NextCh()
			while True:
				if ord(self.ch) == 10:
					level -= 1
					if level == 0:
						self.oldEols = self.line - line0
						self.NextCh()
						return True
					self.NextCh()
				elif self.ch == Buffer.EOF:
					return False
				else:
					self.NextCh()
		else:
			if self.ch == Scanner.EOL:
				self.line -= 1
				self.lineStart = lineStart0
			self.pos = self.pos - 2
			self.buffer.setPos(self.pos + 1)
			self.NextCh()
		return False

	def Comment1(self) -> bool:
		level = 1
		line0 = self.line
		lineStart0 = self.lineStart
		self.NextCh()
		if self.ch == "*":
			self.NextCh()
			while True:
				if self.ch == "*":
					self.NextCh()
					if self.ch == "/":
						level -= 1
						if level == 0:
							self.oldEols = self.line - line0
							self.NextCh()
							return True
						self.NextCh()
				elif self.ch == "/":
					self.NextCh()
					if self.ch == "*":
						level += 1
						self.NextCh()
				elif self.ch == Buffer.EOF:
					return False
				else:
					self.NextCh()
		else:
			if self.ch == Scanner.EOL:
				self.line -= 1
				self.lineStart = lineStart0
			self.pos = self.pos - 2
			self.buffer.setPos(self.pos + 1)
			self.NextCh()
		return False

	literalsTable = prepareLiteralsTable({"COMPILER": ScannerEnum.COMPILER_Sym, "IGNORECASE": ScannerEnum.IGNORECASE_Sym, "CHARACTERS": ScannerEnum.CHARACTERS_Sym, "TOKENS": ScannerEnum.TOKENS_Sym, "NAMES": ScannerEnum.NAMES_Sym, "PRAGMAS": ScannerEnum.PRAGMAS_Sym, "COMMENTS": ScannerEnum.COMMENTS_Sym, "FROM": ScannerEnum.FROM_Sym, "TO": ScannerEnum.TO_Sym, "NESTED": ScannerEnum.NESTED_Sym, "IGNORE": ScannerEnum.IGNORE_Sym, "PRODUCTIONS": ScannerEnum.PRODUCTIONS_Sym, "END": ScannerEnum.END_Sym, "ANY": ScannerEnum.ANY_Sym, "CHR": ScannerEnum.CHR_Sym, "out": ScannerEnum.out_Sym, "WEAK": ScannerEnum.WEAK_Sym, "SYNC": ScannerEnum.SYNC_Sym, "IF": ScannerEnum.IF_Sym, "CONTEXT": ScannerEnum.CONTEXT_Sym})

	def CheckLiteral(self) -> ScannerEnum:
		return self.__class__.literalsTable.get(self.t.val, self.t.kind)

	def scan1(self) -> bool:
		return self.ch == "/" and self.Comment0() or self.ch == "/" and self.Comment1()

	def scan2(self, buf: str) -> str:
		buf += str(self.ch)
		self.NextCh()
		return buf

	def scan3(self, state: int, apx: int, buf: str) -> typing.Tuple[typing.Optional[int], ScannerEnum, int, str]:
		if state == 20:
			if "0" <= self.ch <= "9" or "A" <= self.ch <= "Z" or "a" <= self.ch <= "z":
				buf += str(self.ch)
				self.NextCh()
				return 20, self.t.kind, apx, buf
			self.t.val = buf
			self.t.kind = self.__class__.ENUM.ident_Sym
			return None, self.CheckLiteral(), apx, buf
		if state == 21:
			if "0" <= self.ch <= "9":
				buf += str(self.ch)
				self.NextCh()
				return 21, self.t.kind, apx, buf
			return None, self.__class__.ENUM.number_Sym, apx, buf
		if state == 22:
			if "0" <= self.ch <= "9" or "A" <= self.ch <= "Z" or "a" <= self.ch <= "z":
				buf += str(self.ch)
				self.NextCh()
				return 22, self.t.kind, apx, buf
			return None, self.__class__.ENUM.ddtSym_Sym, apx, buf
		if state == 23:
			if ord(self.ch) <= 9 or 11 <= ord(self.ch) <= 12 or 14 <= ord(self.ch) and self.ch <= "!" or "#" <= self.ch <= "[" or "]" <= self.ch and ord(self.ch) <= 255 or ord(self.ch) > 256:
				buf += str(self.ch)
				self.NextCh()
				return 23, self.t.kind, apx, buf
			if ord(self.ch) == 10 or ord(self.ch) == 13:
				buf += str(self.ch)
				self.NextCh()
				return 2, self.t.kind, apx, buf
			if self.ch == '"':
				buf += str(self.ch)
				self.NextCh()
				return 1, self.t.kind, apx, buf
			if ord(self.ch) == 92:
				buf += str(self.ch)
				self.NextCh()
				return 25, self.t.kind, apx, buf
			return None, self.__class__.ENUM.noSym, apx, buf
		if state == 24:
			if ord(self.ch) <= 9 or 11 <= ord(self.ch) <= 12 or 14 <= ord(self.ch) and self.ch <= "&" or "(" <= self.ch <= "[" or "]" <= self.ch and ord(self.ch) <= 255 or ord(self.ch) > 256:
				buf += str(self.ch)
				self.NextCh()
				return 24, self.t.kind, apx, buf
			if ord(self.ch) == 10 or ord(self.ch) == 13:
				buf += str(self.ch)
				self.NextCh()
				return 2, self.t.kind, apx, buf
			if ord(self.ch) == 39:
				buf += str(self.ch)
				self.NextCh()
				return 1, self.t.kind, apx, buf
			if ord(self.ch) == 92:
				buf += str(self.ch)
				self.NextCh()
				return 26, self.t.kind, apx, buf
			return None, self.__class__.ENUM.noSym, apx, buf
		if state == 25:
			if " " <= self.ch <= "~":
				buf += str(self.ch)
				self.NextCh()
				return 23, self.t.kind, apx, buf
			return None, self.__class__.ENUM.noSym, apx, buf
		if state == 26:
			if " " <= self.ch <= "~":
				buf += str(self.ch)
				self.NextCh()
				return 24, self.t.kind, apx, buf
			return None, self.__class__.ENUM.noSym, apx, buf
		if state == 27:
			if ord(self.ch) <= 9 or 11 <= ord(self.ch) <= 12 or 14 <= ord(self.ch) and self.ch <= "!" or "#" <= self.ch <= "[" or "]" <= self.ch and ord(self.ch) <= 255 or ord(self.ch) > 256:
				buf += str(self.ch)
				self.NextCh()
				return 23, self.t.kind, apx, buf
			if ord(self.ch) == 10 or ord(self.ch) == 13:
				buf += str(self.ch)
				self.NextCh()
				return 2, self.t.kind, apx, buf
			if self.ch == '"':
				buf += str(self.ch)
				self.NextCh()
				return 1, self.t.kind, apx, buf
			if ord(self.ch) == 92:
				buf += str(self.ch)
				self.NextCh()
				return 25, self.t.kind, apx, buf
			return None, self.__class__.ENUM.dquote_Sym, apx, buf
		if state == 28:
			if ord(self.ch) <= 9 or 11 <= ord(self.ch) <= 12 or 14 <= ord(self.ch) and self.ch <= "&" or "(" <= self.ch <= "[" or "]" <= self.ch and ord(self.ch) <= 255 or ord(self.ch) > 256:
				buf += str(self.ch)
				self.NextCh()
				return 24, self.t.kind, apx, buf
			if ord(self.ch) == 10 or ord(self.ch) == 13:
				buf += str(self.ch)
				self.NextCh()
				return 2, self.t.kind, apx, buf
			if ord(self.ch) == 39:
				buf += str(self.ch)
				self.NextCh()
				return 1, self.t.kind, apx, buf
			if ord(self.ch) == 92:
				buf += str(self.ch)
				self.NextCh()
				return 26, self.t.kind, apx, buf
			return None, self.__class__.ENUM.squote_Sym, apx, buf
		if state == 29:
			if self.ch == ".":
				buf += str(self.ch)
				self.NextCh()
				return 6, self.t.kind, apx, buf
			if self.ch == ">":
				buf += str(self.ch)
				self.NextCh()
				return 14, self.t.kind, apx, buf
			if self.ch == ")":
				buf += str(self.ch)
				self.NextCh()
				return 19, self.t.kind, apx, buf
			return None, self.__class__.ENUM.point_Sym, apx, buf
		if state == 30:
			if self.ch == ".":
				buf += str(self.ch)
				self.NextCh()
				return 18, self.t.kind, apx, buf
			return None, self.__class__.ENUM.lparen_Sym, apx, buf
		if state == 31:
			if self.ch == ".":
				buf += str(self.ch)
				self.NextCh()
				return 13, self.t.kind, apx, buf
			return None, self.__class__.ENUM.less_Sym, apx, buf
		return state, self.t.kind, apx, buf

	finalStates = array.array("B", (ScannerEnum.noSym, ScannerEnum.string_Sym, ScannerEnum.badString_Sym, ScannerEnum.equal_Sym, ScannerEnum.plus_Sym, ScannerEnum.minus_Sym, ScannerEnum.pointpoint_Sym, ScannerEnum.rparen_Sym, ScannerEnum.lbrack_Sym, ScannerEnum.rbrack_Sym, ScannerEnum.uparrow_Sym, ScannerEnum.greater_Sym, ScannerEnum.comma_Sym, ScannerEnum.lesspoint_Sym, ScannerEnum.pointgreater_Sym, ScannerEnum.bar_Sym, ScannerEnum.lbrace_Sym, ScannerEnum.rbrace_Sym, ScannerEnum.lparenpoint_Sym, ScannerEnum.pointrparen_Sym))
