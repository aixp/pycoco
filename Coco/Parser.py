"""Parser of CoCoPy files (dialect of CoCo/R).

This is a parser."""
__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""
import ast
import typing
from enum import IntEnum
from functools import wraps

from CoCoRuntime.parser import Parser
from CoCoRuntime.scanner import Position

from .actions import CharAct, State, TransitionCode
from .CharClass import charSetSize
from .charUtils import Unescape
from .CLI import parseArgs
from .Core import Comment, Graph
from .nodes import Node, NodeAny, NodeCharClass, NodeEmpty, NodeNonTerminal, NodeResolverExpr, NodeSemAct, NodeSynchronization, NodeTerminal, NodeWeakTerminal
from .Preamble import Preamble
from .Scanner import ScannerEnum
from .symbols import Symbol, SymbolTokensKinds, SymNonTerminal, SymPragma, SymTerminal


class OurTokenKind(IntEnum):
	id = 0
	str = 1


class ArgObj:
	__slots__ = "name", "type"

	def __init__(self, name: ast.Name = None, type: ast.Name = None) -> None:
		self.name = name
		self.type = type


def _generateSet() -> typing.Tuple[typing.Tuple[bool, ...], ...]:
	T = True
	x = False
	return (T, T, x, T, x, x, x, x, x, T, T, T, x, x, x, T, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x), (x, T, T, T, T, T, x, x, x, x, x, x, T, T, T, x, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T), (T, T, x, T, x, x, x, x, x, T, T, T, x, x, x, T, T, T, T, x, x, x, x, T, x, T, x, T, x, x, x, x, x, x, x, x, x, x, T, T, T, x, T, T, x, T, x, x), (T, T, x, T, x, x, x, x, x, T, T, T, x, x, x, T, T, T, x, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T), (T, T, x, T, x, x, x, x, x, T, T, T, x, x, x, T, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x), (x, T, x, T, x, x, x, x, x, T, T, T, x, x, x, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x), (x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x, x, x, x, x, x), (x, x, x, x, x, x, x, x, x, x, x, T, x, T, T, T, T, x, T, x, x, x, x, x, x, x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x, x, x, x, x), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, T, T, T, x, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, T, T, T, x, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T), (x, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, T), (x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x, x, x, T, x, T, T, T, T, x, x, x, x, x, x, x, x, x, T, T, T, T, T, T, x, T, x, x), (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x, x, x, x, x, x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x, x, x, x, x), (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, T, x, T, x, T, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, x, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T), (x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, T, T, x, T, T, x, T, x, x), (x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, T, x, T, x, x, x, x, x, x, x, x, x, x, x, T, T, x, T, x, x, T, x, x), (x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, T, x, x, x, x, x, x, x, T, x, T, x, x, x, x, x, x, x, x, x, T, x, x, T, x, x, x, x, x, x), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, T, T, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, T, T, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, x, T, T, T, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, x, x, T, T, T, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T, x, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T, x, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T, T, T, T, T, T, T, T, T, T), (x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, x, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T)


class MyParser(Parser):
	__slots__ = ()

	@wraps(Parser.__init__)
	def __init__(self, *args, **kwargs):
		"""This ctor is mandatory, don't delete it: otherwise self.__class__.ENUM will be None"""
		super().__init__(*args, **kwargs)

	ENUM = ScannerEnum
	__main_production_name__ = "Coco"
	__EOF_sym__ = ScannerEnum.EOF_SYM

	def pragmas(self) -> None:
		if self.la.kind == self.__class__.ENUM.ddtSym_Sym:
			self.la.val = "-" + str(self.la.val[1:])
			parseArgs([self.la.val])

	def Coco(self) -> None:
		g = Graph(self.controller.dfa)
		g1 = Graph(self.controller.dfa)
		g2 = Graph(self.controller.dfa)
		s = set()
		beg = self.token.pos
		preamble = self.pythonSource()
		self.controller.preamble = preamble
		self.Expect(self.__class__.ENUM.COMPILER_Sym)
		self.controller.genScanner = True
		self.controller.table.ignored = None
		self.Expect(self.__class__.ENUM.ident_Sym)
		self.controller.gramName = self.token.val
		beg = self.la.pos
		while self.StartOf(1):
			self.Get()
		self.controller.table.semDeclPos = Position(self.scanner.buffer, beg, self.la.pos - beg, 0)
		if self.la.kind == self.__class__.ENUM.IGNORECASE_Sym:
			self.Get()
			self.controller.dfa.ignoreCase = True
		if self.la.kind == self.__class__.ENUM.CHARACTERS_Sym:
			self.Get()
			while self.la.kind == self.__class__.ENUM.ident_Sym:
				self.SetDecl()
		if self.la.kind == self.__class__.ENUM.TOKENS_Sym:
			self.Get()
			while self.la.kind == self.__class__.ENUM.ident_Sym or self.la.kind == self.__class__.ENUM.string_Sym:
				self.TokenDecl(SymTerminal)
		if self.la.kind == self.__class__.ENUM.NAMES_Sym:
			self.Get()
			while self.la.kind == self.__class__.ENUM.ident_Sym:
				self.NameDecl()
		if self.la.kind == self.__class__.ENUM.PRAGMAS_Sym:
			self.Get()
			while self.la.kind == self.__class__.ENUM.ident_Sym or self.la.kind == self.__class__.ENUM.string_Sym:
				self.TokenDecl(SymPragma)
		while self.la.kind == self.__class__.ENUM.COMMENTS_Sym:
			self.Get()
			nested = False
			self.Expect(self.__class__.ENUM.FROM_Sym)
			g1 = self.TokenExpr()
			self.Expect(self.__class__.ENUM.TO_Sym)
			g2 = self.TokenExpr()
			if self.la.kind == self.__class__.ENUM.NESTED_Sym:
				self.Get()
				nested = True
			self.controller.dfa.commentsListHead = Comment(self.controller.dfa.commentsListHead, self.controller.dfa.charClassStorage, g1.l, g2.l, nested, self.controller.errors)
		while self.la.kind == self.__class__.ENUM.IGNORE_Sym:
			self.Get()
			s = self.Set()
			if self.controller.table.ignored is None:
				self.controller.table.ignored = set()
			self.controller.table.ignored |= s
		while not (self.la.kind == self.__class__.ENUM.EOF_SYM or self.la.kind == self.__class__.ENUM.PRODUCTIONS_Sym):
			self.SynErr(48)
			self.Get()
		self.Expect(self.__class__.ENUM.PRODUCTIONS_Sym)
		if self.controller.genScanner:
			self.controller.dfa.MakeDeterministic(self.controller.errors)
		self.controller.table.DeleteNodes()
		while self.la.kind == self.__class__.ENUM.ident_Sym:
			self.Get()
			sym = self.controller.table.findSymbol(self.token.val)
			undef = sym is None
			if undef:
				sym = SymNonTerminal(self.controller.table, self.token.val, self.token.line, self.controller.errors)
			else:
				if isinstance(sym, SymNonTerminal):
					if sym.graph is not None:
						self.SemErr("name declared twice")
				else:
					self.SemErr("this symbol kind not allowed on left side of production")
				sym.line = self.token.line
			noAttrs = not sym.attrs
			sym.attrs = []
			noRet = not sym.returnAttrs
			sym.returnAttrs = []
			if self.la.kind == self.__class__.ENUM.less_Sym or self.la.kind == self.__class__.ENUM.lesspoint_Sym:
				self.AttrDecl(sym)
			if not undef:
				if noAttrs != (not sym.attrs) or noRet != (not sym.returnAttrs):
					self.SemErr("attribute mismatch between declaration and use of this symbol")
			if self.la.kind == self.__class__.ENUM.lparenpoint_Sym:
				sym.semPos = self.SemText()
			self.ExpectWeak(self.__class__.ENUM.equal_Sym, 2)
			g = self.Expression()
			sym.graph = g.l
			Graph.Finish(g)
			self.ExpectWeak(self.__class__.ENUM.point_Sym, 3)
		self.Expect(self.__class__.ENUM.END_Sym)
		self.Expect(self.__class__.ENUM.ident_Sym)
		self.controller.grammarName1 = self.token.val
		self.Expect(self.__class__.ENUM.point_Sym)

	def pythonSource(self) -> Preamble:
		beg = self.la.pos
		linesToStartOfGrammar = None
		try:
			ast.parse(self.scanner.buffer.buf[beg:], mode="exec")
		except SyntaxError as synErr:
			linesToStartOfGrammar = synErr.lineno - 1
		if linesToStartOfGrammar is None:
			raise ValueError("Cannot determine end of python preamble, looks like the whole file is a valid python source")
		if linesToStartOfGrammar < 0:
			linesToStartOfGrammar = 0
		sourceStartLine = self.la.line
		sourceEndLine = sourceStartLine + linesToStartOfGrammar
		end = beg
		while self.StartOf(4):
			self.Get()
			if self.la.line >= sourceEndLine:
				end = self.la.pos
				break
		while end and self.scanner.buffer.buf[end] != "\n":
			end -= 1
		preamble = Preamble(ast.parse(self.scanner.buffer.buf[beg:end], mode="exec").body)
		return preamble

	def SetDecl(self) -> None:
		self.Expect(self.__class__.ENUM.ident_Sym)
		name = self.token.val
		c = self.controller.dfa.charClassStorage.Find(name)
		if c is not None:
			self.SemErr("name declared twice")
		self.Expect(self.__class__.ENUM.equal_Sym)
		s = self.Set()
		if len(s) == 0:
			self.SemErr("character set must not be empty")
		c = self.controller.dfa.charClassStorage.spawn(name, s)
		self.Expect(self.__class__.ENUM.point_Sym)

	def TokenDecl(self, typ: typing.Type[Symbol]) -> None:
		s = self.Sym()
		name, ourKind = s
		sym = self.controller.table.findSymbol(name)
		if sym is not None:
			self.SemErr("name declared twice")
		else:
			sym = typ(self.controller.table, name, self.token.line, self.controller.errors)
			sym.tokenKind = SymbolTokensKinds.fixedToken
		self.tokenString = None
		while not self.StartOf(5):
			self.SynErr(49)
			self.Get()
		if self.la.kind == self.__class__.ENUM.equal_Sym:
			self.Get()
			g = self.TokenExpr()
			self.Expect(self.__class__.ENUM.point_Sym)
			if ourKind == OurTokenKind.str:
				self.SemErr("a literal must not be declared with a structure")
			Graph.Finish(g)
			if self.tokenString is None or self.tokenString == self.noString:
				self.controller.dfa.ConvertToStates(g.l, sym, self.controller.errors)
			else:
				if self.controller.table.literals.get(self.tokenString) is not None:
					self.SemErr("token string declared twice")
				self.controller.table.literals[self.tokenString] = sym
				self.controller.dfa.MatchLiteral(self.tokenString, sym, self.controller.errors)
		elif self.StartOf(6):
			if ourKind == OurTokenKind.id:
				self.controller.genScanner = False
			else:
				self.controller.dfa.MatchLiteral(sym.name, sym, self.controller.errors)
		else:
			self.SynErr(50)
		if self.la.kind == self.__class__.ENUM.lparenpoint_Sym:
			sym.semPos = self.SemText()
			if typ is not SymPragma:
				self.SemErr("semantic action not allowed here")

	def NameDecl(self) -> None:
		self.Expect(self.__class__.ENUM.ident_Sym)
		alias = self.token.val
		self.Expect(self.__class__.ENUM.equal_Sym)
		if self.la.kind == self.__class__.ENUM.ident_Sym:
			self.Get()
		elif self.la.kind == self.__class__.ENUM.string_Sym:
			self.Get()
		else:
			self.SynErr(51)
		self.controller.table.NewName(alias, self.token.val, self.controller.errors)
		self.Expect(self.__class__.ENUM.point_Sym)

	def TokenExpr(self) -> Graph:
		g = self.TokenTerm()
		first = True
		while self.WeakSeparator(self.__class__.ENUM.bar_Sym, 7, 8):
			g2 = self.TokenTerm()
			if first:
				g.MakeFirstAlt(self.controller.table)
				first = False
			g.MakeAlternative(self.controller.table, g2)
		return g

	def Set(self) -> typing.Union[int, str]:
		s = self.SimSet()
		while self.la.kind == self.__class__.ENUM.plus_Sym or self.la.kind == self.__class__.ENUM.minus_Sym:
			if self.la.kind == self.__class__.ENUM.plus_Sym:
				self.Get()
				s2 = self.SimSet()
				s |= s2
			else:
				self.Get()
				s2 = self.SimSet()
				s -= s2
		return s

	def AttrDecl(self, sym: Symbol) -> None:
		if self.la.kind == self.__class__.ENUM.less_Sym:
			self.Get()
			if self.la.kind == self.__class__.ENUM.uparrow_Sym or self.la.kind == self.__class__.ENUM.out_Sym:
				if self.la.kind == self.__class__.ENUM.uparrow_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.out_Sym:
					self.Get()
				else:
					self.SynErr(52)
				outArg = self.SingleArgDecl(sym)
				sym.returnAttrs.append(outArg)
				if self.la.kind == self.__class__.ENUM.greater_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.greater_Sym or self.la.kind == self.__class__.ENUM.comma_Sym:
					while self.la.kind == self.__class__.ENUM.comma_Sym:
						self.Get()
						inArg = self.SingleArgDecl(sym)
						sym.attrs.append(inArg)
					self.Get()
				else:
					self.SynErr(53)
			elif self.StartOf(4):
				if self.StartOf(4):
					inArg = self.SingleArgDecl(sym)
					sym.attrs.append(inArg)
					while self.la.kind == self.__class__.ENUM.comma_Sym:
						self.Get()
						inArg = self.SingleArgDecl(sym)
						sym.attrs.append(inArg)
				self.Expect(self.__class__.ENUM.greater_Sym)
			else:
				self.SynErr(54)
		elif self.la.kind == self.__class__.ENUM.lesspoint_Sym:
			self.Get()
			if self.la.kind == self.__class__.ENUM.uparrow_Sym or self.la.kind == self.__class__.ENUM.out_Sym:
				if self.la.kind == self.__class__.ENUM.uparrow_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.out_Sym:
					self.Get()
				else:
					self.SynErr(55)
				outArg = self.SingleArgDecl(sym)
				sym.returnAttrs.append(outArg)
				if self.la.kind == self.__class__.ENUM.pointgreater_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.comma_Sym or self.la.kind == self.__class__.ENUM.pointgreater_Sym:
					while self.la.kind == self.__class__.ENUM.comma_Sym:
						self.Get()
						inArg = self.SingleArgDecl(sym)
						sym.attrs.append(inArg)
					self.Get()
				else:
					self.SynErr(56)
			elif self.StartOf(9):
				while self.StartOf(10):
					if self.StartOf(11):
						self.Get()
					else:
						self.Get()
						self.SemErr("bad string in attributes d")
				self.Expect(self.__class__.ENUM.pointgreater_Sym)
			else:
				self.SynErr(57)
		else:
			self.SynErr(58)

	def SemText(self) -> Position:
		self.Expect(self.__class__.ENUM.lparenpoint_Sym)
		beg = self.la.pos
		col = self.la.col
		while self.StartOf(12):
			if self.StartOf(13):
				self.Get()
			elif self.la.kind == self.__class__.ENUM.badString_Sym:
				self.Get()
				self.SemErr("bad string in semantic action")
			else:
				self.Get()
				self.SemErr("missing end of previous semantic action")
		self.Expect(self.__class__.ENUM.pointrparen_Sym)
		pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col)
		return pos

	def Expression(self) -> Graph:
		g = self.Term()
		assert g.l is not None
		first = True
		while self.WeakSeparator(self.__class__.ENUM.bar_Sym, 14, 15):
			g2 = self.Term()
			if first:
				g.MakeFirstAlt(self.controller.table)
				first = False
			g.MakeAlternative(self.controller.table, g2)
		return g

	def SimSet(self) -> typing.Set[typing.Union[int, str]]:
		n1 = 0
		n2 = 0
		name = ""
		s = set()
		mx = charSetSize
		if self.la.kind == self.__class__.ENUM.ident_Sym:
			self.Get()
			c = self.controller.dfa.charClassStorage.Find(self.token.val)
			if c is None:
				self.SemErr("undefined name")
			else:
				s |= c.set
		elif self.la.kind == self.__class__.ENUM.string_Sym:
			name = self.String()
			if self.StartOf(16):
				for c in name:
					if self.controller.dfa.ignoreCase:
						s.add(ord(c.lower()))
					else:
						s.add(ord(c))
			elif self.la.kind == self.__class__.ENUM.pointpoint_Sym:
				if len(name) != 1 or ord(name[0]) > mx - 1:
					self.SemErr("unacceptable character value")
				else:
					n1 = ord(name[0]) % mx
				if self.controller.dfa.ignoreCase and ord("A") <= n1 <= ord("Z"):
					n1 += 32
				self.Get()
				if self.la.kind == self.__class__.ENUM.string_Sym:
					name = self.String()
					if len(name) != 1 or ord(name[0]) > mx - 1:
						self.SemErr("unacceptable character value")
					else:
						n2 = ord(name[0]) % mx
					if self.controller.dfa.ignoreCase and ord("A") <= n2 <= ord("Z"):
						n2 += 32
				elif self.la.kind == self.__class__.ENUM.CHR_Sym:
					n2 = self.SingleChar(mx)
				else:
					self.SynErr(59)
				for i in range(n1, n2 + 1):
					s.add(i)
			else:
				self.SynErr(60)
		elif self.la.kind == self.__class__.ENUM.CHR_Sym:
			n1 = self.SingleChar(mx)
			s.add(n1)
			if self.la.kind == self.__class__.ENUM.pointpoint_Sym:
				self.Get()
				if self.la.kind == self.__class__.ENUM.string_Sym:
					name = self.String()
					if len(name) != 1 or ord(name[0]) > mx - 1:
						self.SemErr("unacceptable character value")
					else:
						n2 = ord(name[0]) % mx
					if self.controller.dfa.ignoreCase and ord("A") <= n2 <= ord("Z"):
						n2 += 32
				elif self.la.kind == self.__class__.ENUM.CHR_Sym:
					n2 = self.SingleChar(mx)
				else:
					self.SynErr(61)
				for i in range(n1, n2):
					s.add(i)
		elif self.la.kind == self.__class__.ENUM.ANY_Sym:
			self.Get()
			s = set()
			for num in range(0, charSetSize):
				s.add(num)
			s.add("ANYCHAR")
		else:
			self.SynErr(62)
		return s

	def String(self) -> str:
		self.Expect(self.__class__.ENUM.string_Sym)
		name = self.token.val
		name = Unescape(name[1:-1], self.errors)
		return name

	def SingleChar(self, mx: int) -> int:
		n = 0
		self.Expect(self.__class__.ENUM.CHR_Sym)
		self.Expect(self.__class__.ENUM.lparen_Sym)
		self.Expect(self.__class__.ENUM.number_Sym)
		n = int(self.token.val)
		if n > mx - 1:
			self.SemErr("unacceptable character value")
		if self.controller.dfa.ignoreCase and ord("A") <= n <= ord("Z"):
			n += 32
		n %= mx
		self.Expect(self.__class__.ENUM.rparen_Sym)
		return n

	def Sym(self) -> typing.Tuple[str, OurTokenKind]:
		name = "???"
		ourKind = OurTokenKind.id
		if self.la.kind == self.__class__.ENUM.ident_Sym:
			self.Get()
			ourKind = OurTokenKind.id
			name = self.token.val
		elif self.la.kind == self.__class__.ENUM.string_Sym:
			self.Get()
			ourKind = OurTokenKind.str
			name = '"' + self.token.val[1:-1] + '"'
			if self.controller.dfa.ignoreCase:
				name = name.lower()
			if name.find(" ") >= 0:
				self.SemErr("literal tokens must not contain blanks")
		else:
			self.SynErr(63)
		s = name, ourKind
		return s

	def SingleArgDecl(self, sym: SymNonTerminal) -> ArgObj:
		typ = ""
		squareBracesCount = 0
		singleQuotesCount = 0
		doubleQuotesCount = 0
		while self.StartOf(4):
			if self.StartOf(17):
				self.Get()
				if self.la.kind in (self.__class__.ENUM.greater_Sym, self.__class__.ENUM.comma_Sym):
					if squareBracesCount == 0 and singleQuotesCount & 1 == 0 and doubleQuotesCount & 1 == 0:
						if self.token.kind == self.__class__.ENUM.ident_Sym:
							name = ast.parse(self.token.val, mode="eval")
							if typ:
								typ = ast.parse(typ, mode="eval")
								if isinstance(typ, ast.Expression):
									typ = typ.body
							break
						raise ValueError("Token name must be an identifier:", self.token.val)
			elif self.la.kind == self.__class__.ENUM.lbrack_Sym:
				self.Get()
				squareBracesCount += 1
			elif self.la.kind == self.__class__.ENUM.rbrack_Sym:
				self.Get()
				squareBracesCount -= 1
			elif self.la.kind == self.__class__.ENUM.squote_Sym:
				self.Get()
				singleQuotesCount += 1
			else:
				self.Get()
				doubleQuotesCount += 1
			typ += self.token.val
		argObj = ArgObj(name, typ)
		return argObj

	def Term(self) -> Graph:
		rslv = None
		g = None
		if self.StartOf(18):
			if self.la.kind == self.__class__.ENUM.IF_Sym:
				rslv = NodeResolverExpr(self.controller.table, self.la.line)
				rslv.pos = self.Resolver()
				g = Graph(self.controller.dfa, rslv)
				assert g.l is not None
			g2 = self.Factor()
			if rslv is not None:
				g.MakeSequence(g2)
			else:
				g = g2
				assert g.l is not None
			while self.StartOf(19):
				g2 = self.Factor()
				g.MakeSequence(g2)
		elif self.StartOf(20):
			g = Graph(self.controller.dfa, NodeEmpty(self.controller.table))
			assert g.l is not None
		else:
			self.SynErr(64)
		if g is None:
			g = Graph(self.controller.dfa, NodeEmpty(self.controller.table))
			assert g.l is not None
		return g

	def Resolver(self) -> Position:
		self.Expect(self.__class__.ENUM.IF_Sym)
		self.Expect(self.__class__.ENUM.lparen_Sym)
		beg = self.la.pos
		col = self.la.col
		self.Condition()
		pos = Position(self.scanner.buffer, beg, self.token.pos - beg, col)
		return pos

	def Factor(self) -> Graph:
		weak = False
		g = None
		if self.la.kind == self.__class__.ENUM.ident_Sym or self.la.kind == self.__class__.ENUM.string_Sym or self.la.kind == self.__class__.ENUM.WEAK_Sym:
			if self.la.kind == self.__class__.ENUM.WEAK_Sym:
				self.Get()
				weak = True
			s = self.Sym()
			name, ourKind = s
			sym = self.controller.table.findSymbol(name)
			if sym is None and ourKind == OurTokenKind.str:
				sym = self.controller.table.literals.get(name)
			undef = sym is None
			if undef:
				if ourKind == OurTokenKind.id:
					sym = SymNonTerminal(self.controller.table, name, 0, self.controller.errors)
				elif self.controller.genScanner:
					sym = SymTerminal(self.controller.table, name, self.token.line, self.controller.errors)
					self.controller.dfa.MatchLiteral(sym.name, sym, self.controller.errors)
				else:
					self.SemErr("undefined string in production")
					sym = self.controller.table.eofSy
			if isinstance(sym, SymTerminal):
				ctor = NodeTerminal
			elif isinstance(sym, SymNonTerminal):
				ctor = NodeNonTerminal
			else:
				self.SemErr("this symbol kind is not allowed in a production")
			if weak:
				if isinstance(sym, SymTerminal):
					ctor = NodeWeakTerminal
				else:
					self.SemErr("only terminals may be weak")
			p = ctor(self.controller.table, sym, self.token.line)
			g = Graph(self.controller.dfa, p)
			if self.la.kind == self.__class__.ENUM.less_Sym or self.la.kind == self.__class__.ENUM.lesspoint_Sym:
				self.Attribs(p)
				if ourKind != OurTokenKind.id:
					self.SemErr("a literal must not have attributes")
			if undef:
				sym.attrs = p.attrs
				sym.returnAttrs = p.returnAttrs
			elif bool(p.attrs) != bool(sym.attrs) or bool(p.returnAttrs) != bool(sym.returnAttrs):
				self.SemErr("attribute mismatch between declaration and use of this symbol:" + repr(p.attrs) + ", " + repr(sym.attrs) + ", " + repr(p.returnAttrs) + ", " + repr(sym.returnAttrs))
		elif self.la.kind == self.__class__.ENUM.lparen_Sym:
			self.Get()
			g = self.Expression()
			self.Expect(self.__class__.ENUM.rparen_Sym)
			assert g.l is not None
		elif self.la.kind == self.__class__.ENUM.lbrack_Sym:
			self.Get()
			g = self.Expression()
			self.Expect(self.__class__.ENUM.rbrack_Sym)
			g.MakeOption(self.controller.table)
			assert g.l is not None
		elif self.la.kind == self.__class__.ENUM.lbrace_Sym:
			self.Get()
			g = self.Expression()
			self.Expect(self.__class__.ENUM.rbrace_Sym)
			g.MakeIteration(self.controller.table)
			assert g.l is not None
		elif self.la.kind == self.__class__.ENUM.lparenpoint_Sym:
			pos = self.SemText()
			p = NodeSemAct(self.controller.table, 0)
			p.pos = pos
			g = Graph(self.controller.dfa, p)
			assert g.l is not None
		elif self.la.kind == self.__class__.ENUM.ANY_Sym:
			self.Get()
			p = NodeAny(self.controller.table, 0)
			assert p is not None
			g = Graph(self.controller.dfa, p)
			assert g.l is not None
		elif self.la.kind == self.__class__.ENUM.SYNC_Sym:
			self.Get()
			p = NodeSynchronization(self.controller.table, 0)
			assert p is not None
			g = Graph(self.controller.dfa, p)
			assert g.l is not None
		else:
			self.SynErr(65)
		if g is None:
			g = Graph(self.controller.dfa, NodeEmpty(self.controller.table))
			assert g.l is not None
		return g

	def Attribs(self, n: Node) -> None:
		if self.la.kind == self.__class__.ENUM.less_Sym:
			self.Get()
			if self.la.kind == self.__class__.ENUM.uparrow_Sym or self.la.kind == self.__class__.ENUM.out_Sym:
				if self.la.kind == self.__class__.ENUM.uparrow_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.out_Sym:
					self.Get()
				else:
					self.SynErr(66)
				beg = self.la.pos
				while self.StartOf(21):
					if self.StartOf(22):
						self.Get()
					else:
						self.Get()
						self.SemErr("bad string in attributes e")
				if n.returnAttrs is None:
					n.returnAttrs = []
					n.returnAttrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.la.pos), mode="eval")))
				if self.la.kind == self.__class__.ENUM.greater_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.comma_Sym:
					self.Get()
					beg = self.la.pos
					col = self.la.col
					while self.StartOf(23):
						if self.StartOf(24):
							self.Get()
						else:
							self.Get()
							self.SemErr("bad string in attributes f")
					self.Expect(self.__class__.ENUM.greater_Sym)
					if self.token.pos > beg:
						if n.attrs is None:
							n.attrs = []
							n.attrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.token.pos), mode="eval")))
				else:
					self.SynErr(67)
			elif self.StartOf(9):
				beg = self.la.pos
				col = self.la.col
				while self.StartOf(25):
					if self.StartOf(26):
						self.Get()
					else:
						self.Get()
						self.SemErr("bad string in attributes g")
				self.Expect(self.__class__.ENUM.greater_Sym)
				if self.token.pos > beg:
					if n.attrs is None:
						n.attrs = []
						n.attrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.token.pos), mode="eval")))
			else:
				self.SynErr(68)
		elif self.la.kind == self.__class__.ENUM.lesspoint_Sym:
			self.Get()
			if self.la.kind == self.__class__.ENUM.uparrow_Sym or self.la.kind == self.__class__.ENUM.out_Sym:
				if self.la.kind == self.__class__.ENUM.uparrow_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.out_Sym:
					self.Get()
				else:
					self.SynErr(69)
				beg = self.la.pos
				while self.StartOf(27):
					if self.StartOf(28):
						self.Get()
					else:
						self.Get()
						self.SemErr("bad string in attributes h")
				if n.returnAttrs is None:
					n.returnAttrs = []
					n.returnAttrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.la.pos), mode="eval")))
				if self.la.kind == self.__class__.ENUM.pointgreater_Sym:
					self.Get()
				elif self.la.kind == self.__class__.ENUM.comma_Sym:
					self.Get()
					beg = self.la.pos
					col = self.la.col
					while self.StartOf(29):
						if self.StartOf(30):
							self.Get()
						else:
							self.Get()
							self.SemErr("bad string in attributes i")
					self.Expect(self.__class__.ENUM.pointgreater_Sym)
					if self.token.pos > beg:
						if n.attrs is None:
							n.attrs = []
							n.attrs.append(ArgObj(ast.parse(self.scanner.buffer.getString(beg, self.token.pos), mode="eval")))
				else:
					self.SynErr(70)
			elif self.StartOf(9):
				beg = self.la.pos
				col = self.la.col
				while self.StartOf(10):
					if self.StartOf(11):
						self.Get()
					else:
						self.Get()
						self.SemErr("bad string in attributes j")
				self.Expect(self.__class__.ENUM.pointgreater_Sym)
				if self.token.pos > beg:
					if n.attrs is None:
						n.attrs = []
					n.attrs.append(ArgObj(self.scanner.buffer.getString(beg, self.token.pos)))
			else:
				self.SynErr(71)
		else:
			self.SynErr(72)

	def Condition(self) -> None:
		while self.StartOf(31):
			if self.la.kind == self.__class__.ENUM.lparen_Sym:
				self.Get()
				self.Condition()
			else:
				self.Get()
		self.Expect(self.__class__.ENUM.rparen_Sym)

	def TokenTerm(self) -> Graph:
		g = self.TokenFactor()
		while self.StartOf(7):
			g2 = self.TokenFactor()
			g.MakeSequence(g2)
		if self.la.kind == self.__class__.ENUM.CONTEXT_Sym:
			self.Get()
			self.Expect(self.__class__.ENUM.lparen_Sym)
			g2 = self.TokenExpr()
			g.SetContextTrans(g2.l)
			g.MakeSequence(g2)
			self.Expect(self.__class__.ENUM.rparen_Sym)
		return g

	def TokenFactor(self) -> Graph:
		g = None
		if self.la.kind == self.__class__.ENUM.ident_Sym or self.la.kind == self.__class__.ENUM.string_Sym:
			s = self.Sym()
			name, ourKind = s
			if ourKind == OurTokenKind.id:
				c = self.controller.dfa.charClassStorage.Find(name)
				if c is None:
					c = self.controller.table.findSymbol(name)
					if c is None:
						self.SemErr("undefined name " + name)
						c = self.controller.dfa.charClassStorage.spawn(name, set())
				p = NodeCharClass(self.controller.table, c.n, 0)
				g = Graph(self.controller.dfa, p)
				self.tokenString = self.noString
			else:
				g = Graph.StrToGraph(self.controller, name, self.errors)
				if self.tokenString is None:
					self.tokenString = name
				else:
					self.tokenString = self.noString
		elif self.la.kind == self.__class__.ENUM.lparen_Sym:
			self.Get()
			g = self.TokenExpr()
			self.Expect(self.__class__.ENUM.rparen_Sym)
		elif self.la.kind == self.__class__.ENUM.lbrack_Sym:
			self.Get()
			g = self.TokenExpr()
			self.Expect(self.__class__.ENUM.rbrack_Sym)
			g.MakeOption(self.controller.table)
		elif self.la.kind == self.__class__.ENUM.lbrace_Sym:
			self.Get()
			g = self.TokenExpr()
			self.Expect(self.__class__.ENUM.rbrace_Sym)
			g.MakeIteration(self.controller.table)
		else:
			self.SynErr(73)
		if g is None:
			g = Graph(self.controller.dfa, NodeEmpty(self.controller.table))
			assert g.l is not None
		return g

	set = _generateSet()
	errorMessages = "EOF expected", "ident expected", "number expected", "string expected", "badString expected", '"COMPILER" expected', '"IGNORECASE" expected', '"CHARACTERS" expected', '"TOKENS" expected', '"NAMES" expected', '"PRAGMAS" expected', '"COMMENTS" expected', '"FROM" expected', '"TO" expected', '"NESTED" expected', '"IGNORE" expected', '"PRODUCTIONS" expected', '"=" expected', '"." expected', '"END" expected', '"+" expected', '"-" expected', '".." expected', '"ANY" expected', '"CHR" expected', '"(" expected', '")" expected', '"[" expected', '"]" expected', '"\\\'" expected', '""" expected', '"<" expected', '"^" expected', '"out" expected', '">" expected', '"," expected', '"<." expected', '".>" expected', '"|" expected', '"WEAK" expected', '"{" expected', '"}" expected', '"SYNC" expected', '"IF" expected', '"CONTEXT" expected', '"(." expected', '".)" expected', "??? expected", "this symbol not expected in Coco", "this symbol not expected in TokenDecl", "invalid TokenDecl", "invalid NameDecl", "invalid AttrDecl", "invalid AttrDecl", "invalid AttrDecl", "invalid AttrDecl", "invalid AttrDecl", "invalid AttrDecl", "invalid AttrDecl", "invalid SimSet", "invalid SimSet", "invalid SimSet", "invalid SimSet", "invalid Sym", "invalid Term", "invalid Factor", "invalid Attribs", "invalid Attribs", "invalid Attribs", "invalid Attribs", "invalid Attribs", "invalid Attribs", "invalid Attribs", "invalid TokenFactor"
