"""Core.py -- the computation routines"""

__gpl_exception_generated__ = """If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code

__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.
""" + __gpl_exception_generated__  # pylint: disable=duplicate-code


import typing
from enum import IntEnum

from CoCoRuntime.errors import Errors

from .actions import TransitionCode
from .CharClass import CharClassStorage
from .charUtils import Unescape
from .nodes import Node, NodeAlphabet, NodeAlternative, NodeCharacter, NodeCharClass, NodeIteration, NodeOption


class Comment:
	"""info about comment syntax"""

	__slots__ = ("start", "stop", "nested", "next")

	first = None  # list of comments

	def __init__(self, nextListItem: "Comment", charClassStorage: CharClassStorage, frm: Node, to: Node, nested: bool, errors: Errors) -> None:
		assert isinstance(frm, Node)
		assert isinstance(to, Node)
		assert isinstance(nested, bool)
		self.start = self.Str(frm, charClassStorage, errors)
		self.stop = self.Str(to, charClassStorage, errors)
		self.nested = nested
		self.next = nextListItem

	@staticmethod
	def Str(p: Node, charClassStorage: CharClassStorage, errors: Errors) -> str:
		assert isinstance(p, Node)
		s = ""  # StringBuffer
		while p is not None:
			if isinstance(p, NodeCharacter):
				s += chr(p.val)
			elif isinstance(p, NodeCharClass):
				st = charClassStorage.Set(p.val)  # BitSet
				if len(st) != 1:
					errors.storeError(-1, -1, "character set contains more than 1 character")
				s += chr(min(st))
				# s += chr(st.First())
			else:
				errors.storeError(-1, -1, "comment delimiters may not be structured")
			p = p.next
		if len(s) == 0 or len(s) > 2:
			errors.storeError(-1, -1, "comment delimiters must be 1 or 2 characters long")
			s = "?"
		return s


class LL1ErrorCondition(IntEnum):
	severalAlts = 1
	isDeleteable = 2
	anyDoesntMatch = 3
	mustNotBeDeletable = 4


ll1ErrorsConditionsDescriptions = {
	LL1ErrorCondition.severalAlts: "the start of several alternatives",
	LL1ErrorCondition.isDeleteable: "the start & successor of a deletable structure",
	LL1ErrorCondition.anyDoesntMatch: "an ANY node that matches no symbol",
	LL1ErrorCondition.severalAlts: "contents of [...] or {...} must not be deletable",
}


class Graph:
	__slots__ = ("dfa", "l", "r")

	def __init__(self, dfa: "DFA", p: typing.Optional[Node] = None) -> None:
		self.dfa = dfa
		assert isinstance(p, Node) or (p is None)

		self.l = p  # Node,  left end of graph = head
		self.r = p  # Node,  right end of graph = list of nodes to be linked to successor graph

	def MakeFirstAlt(self, table: "Tab") -> None:
		self.l = NodeAlternative(table, self.l)
		self.l.line = self.l.sub.line  # make line available for error handling */
		self.l.next = self.r
		self.r = self.l

	def MakeAlternative(self, table: "Tab", g2: "Graph") -> None:
		assert isinstance(g2, Graph)
		g2.l = NodeAlternative(table, g2.l)
		g2.l.line = g2.l.sub.line
		p = self.l
		while p.down is not None:
			p = p.down
		p.down = g2.l
		p = self.r
		while p.next is not None:
			p = p.next
		p.next = g2.r

	def MakeSequence(self, g2: "Graph") -> None:
		assert isinstance(g2, Graph)
		p = self.r.next
		self.r.next = g2.l  # link head node
		while p is not None:  # link substructure
			q = p.next
			p.next = g2.l
			p.up = True
			p = q
		self.r = g2.r

	def MakeIteration(self, table: "Tab") -> None:
		self.l = NodeIteration(table, self.l)
		p = self.r
		self.r = self.l
		while p is not None:
			q = p.next
			p.next = self.l
			p.up = True
			p = q

	def MakeOption(self, table: "Tab") -> None:
		self.l = NodeOption(table, self.l)
		self.l.next = self.r
		self.r = self.l

	def Finish(self) -> None:
		p = self.r
		while p is not None:
			q = p.next
			p.next = None
			p = q

	def SetContextTrans(self, p: Node) -> None:
		"""set transition code in the graph rooted at p"""
		assert isinstance(p, Node) or (p is None)
		self.dfa.hasCtxMoves = True
		while p is not None:
			if isinstance(p, NodeAlphabet):
				p.code = TransitionCode.contextTrans
			elif isinstance(p, (NodeOption, NodeIteration)):
				self.SetContextTrans(p.sub)
			elif isinstance(p, NodeAlternative):
				self.SetContextTrans(p.sub)
				self.SetContextTrans(p.down)
			if p.up:
				break
			p = p.next

	@staticmethod
	def StrToGraph(controller: "Controller", st: str, errors: Errors) -> "Graph":
		assert isinstance(st, str)
		s = Unescape(st[1:-1], errors)
		if len(s) == 0:
			errors.storeError(-1, -1, "empty token not allowed")
		g = Graph(controller.dfa)
		g.r = controller.table.dummyNode
		for el in s:
			p = NodeCharacter(controller.table, ord(el), 0)
			g.r.next = p
			g.r = p
		g.l = controller.table.dummyNode.next
		controller.table.dummyNode.next = None
		return g


class UserDefinedTokenName:
	__slots__ = ("alias", "name")

	NameTab = []

	def __init__(self, alias, name):
		assert isinstance(alias, str)
		assert isinstance(name, str)
		self.alias = alias
		self.name = name
		self.__class__.NameTab.append(self)
