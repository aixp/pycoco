"""
The parser generation routines.
"""

__gpl_exception_generated__ = """
If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code

__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.
""" + __gpl_exception_generated__  # pylint: disable=duplicate-code

import ast
import copy
import typing
from enum import IntEnum

from .CodeGenerator import CopySourcePart, GenCodePragmas, conditionFromSourcePart, falseAST, genClassStub, genSelfExpectCall, genSelfLaKindComp, genSelfSynErrCall, genStartOfCall, genTypingUniformTuple, noneAST, printTermName, selfArgAST, selfExpectWeakAST, selfGetCallAST, selfNameAST, selfWeakSeparatorAST, trueAST
from .defaults import baseParserClassName, baseScannerClassName, defaultParserSystemImports, enumTypeMemberName, eofSymbolMemberName, errorMessagesCollectionMemberName, generatedParserClassName, mainProductionNameMemberName, parserDocPostfix, runtimeBasePackage, runtimeParserModule, runtimeScannerModule, scannerEnumName
from .nodes import Node, NodeAlternative, NodeAny, NodeEmpty, NodeIteration, NodeNonTerminal, NodeOption, NodeResolverExpr, NodeSemAct, NodeSynchronization, NodeTerminal, NodeWeakTerminal
from .Preamble import Preamble
from .symbols import Symbol
from .Tab import Tab
from .utils import DefaultDictRestIter, literalToAST

tracing = False


class MyLoopBreak(Exception):
	__slots__ = ()


class ParserErrorCodes(IntEnum):
	tErr = 0
	altErr = 1
	syncErr = 2


class ParserGen:
	__slots__ = ("srcName", "srcDir", "curSy", "err", "symSet")

	maxTerm = 3  # sets of size < maxTerm are enumerated
	ls = "\n"

	@staticmethod
	def Overlaps(s1, s2):
		assert isinstance(s1, set)
		assert isinstance(s2, set)
		ln = len(s1)
		for i in range(0, ln):
			if (i in s1) and (i in s2):
				return True
		return False

	def GenErrorMsg(self, errTyp: ParserErrorCodes, sym: Symbol) -> None:
		assert isinstance(errTyp, int)
		assert isinstance(sym, Symbol)

		errorMessage = None
		if errTyp == ParserErrorCodes.tErr:
			errorMessage = str(sym.name) + " expected"
		elif errTyp == ParserErrorCodes.altErr:
			errorMessage = "invalid " + str(sym.name)
		elif errTyp == ParserErrorCodes.syncErr:
			errorMessage = "this symbol not expected in " + str(sym.name)
		self.err.append(errorMessage)

	@property
	def errorNr(self) -> int:
		return len(self.err) - 1

	def NewCondSet(self, s: typing.Set[int]) -> ast.Num:
		assert isinstance(s, set)
		for i in range(1, len(self.symSet)):
			# skip symSet[0] (reserved for union of SYNC sets)
			if s == self.symSet[i]:  # s.equals( self.symSet[i] ):
				return ast.Num(i)
		self.symSet.append(copy.copy(s))
		return ast.Num(len(self.symSet) - 1)

	def GenCond(self, table: "Tab", s: typing.Set[int], p: Node) -> typing.Union[ast.Call, ast.BoolOp]:
		assert isinstance(s, set)
		assert isinstance(p, Node)
		if isinstance(p, NodeResolverExpr):
			return conditionFromSourcePart(p.pos, 0)

		n = len(s)
		if n == 0:
			return falseAST  # should never happen

		if n <= self.__class__.maxTerm:
			els = []
			for i in range(0, len(table.terminals)):
				sym = table.terminals[i]
				assert isinstance(sym, Symbol)
				if sym.n in s:
					els.append(genSelfLaKindComp(printTermName(sym)))
					n -= 1
			return ast.BoolOp(op=ast.Or(), values=els)

		return genStartOfCall(self.NewCondSet(s))

	def GenCode(self, table: Tab, p: typing.Optional[Node], isChecked: typing.Set[int]) -> typing.Iterator[typing.Union[ast.Expr, ast.Assign, ast.If, ast.While]]:
		# assert isinstance( p, Node )
		assert isinstance(isChecked, set)
		while p is not None:
			if isinstance(p, NodeNonTerminal):  # Non-Terminals
				argz = [ast.Name(a.name) for a in p.attrs] if p.attrs else []
				curRes = ast.Call(
					func=ast.Attribute(value=selfNameAST, attr=p.sym.name),
					args=argz,
					keywords=[],
				)
				if p.returnAttrs:
					if len(p.returnAttrs) > 1:
						retz = ast.Tuple(
							els=[
								(ast.Name(a) if isinstance(a, str) else ast.Name(a.name))
								for a in p.returnAttrs
							]
						)
					else:
						retz = ast.Name(
							(
								ast.Name(p.returnAttrs[0])
								if isinstance(p.returnAttrs[0], str)
								else ast.Name(p.returnAttrs[0].name)
							)
						)
					curRes = ast.Assign(targets=[retz], value=curRes)
				else:
					curRes = ast.Expr(curRes)

				yield curRes

			elif isinstance(p, NodeTerminal):  # Terminals
				if p.sym.n in isChecked:
					yield selfGetCallAST
				else:
					yield genSelfExpectCall(printTermName(p.sym))

			elif isinstance(p, NodeWeakTerminal):
				s1 = table.Expected(p.next, self.curSy)
				s1 |= table.allSyncSets
				yield ast.Expr(
					ast.Call(
						func=selfExpectWeakAST,
						args=[
							printTermName(p.sym),
							self.NewCondSet(s1),
						],
						keywords=[],
					)
				)

			elif isinstance(p, NodeAny):
				yield selfGetCallAST
			elif isinstance(p, NodeEmpty):
				yield ast.Pass()
			elif isinstance(p, NodeResolverExpr):
				# yield (ast.Pass)
				pass  # Nothing to do
			elif isinstance(p, NodeSemAct):
				yield from CopySourcePart(p.pos)
			elif isinstance(p, NodeSynchronization):
				self.GenErrorMsg(ParserErrorCodes.syncErr, self.curSy)
				s1 = copy.copy(p.set)
				yield ast.While(
					test=ast.UnaryOp(op=ast.Not(), operand=self.GenCond(table, s1, p)),
					body=[
						genSelfSynErrCall(self.errorNr),
						selfGetCallAST,
					],
					orelse=[],
				)

			elif isinstance(p, NodeAlternative):
				s1 = table.First(p)
				p2 = p
				equal = s1 == isChecked
				lastIfNode = rootIfNode = None

				while p2 is not None:
					s1 = table.Expected(p2.sub, self.curSy)
					ifNode = ast.If(test=None, body=[], orelse=[])
					selectedBody = None

					if rootIfNode is None:
						lastIfNode = rootIfNode = ifNode
						ifNode.test = self.GenCond(table, s1, p2.sub)
						selectedBody = ifNode.body
					elif p2.down is None and equal:
						selectedBody = lastIfNode.orelse
					else:
						lastIfNode.orelse.append(ifNode)
						lastIfNode = ifNode
						ifNode.test = self.GenCond(table, s1, p2.sub)
						selectedBody = ifNode.body

					s1 |= isChecked
					selectedBody.extend(self.GenCode(table, p2.sub, s1))
					p2 = p2.down
				if not equal:
					self.GenErrorMsg(ParserErrorCodes.altErr, self.curSy)
					lastIfNode.orelse.append(
						ast.Expr(
							value=ast.Call(
								func=ast.Attribute(value=ast.Name("self"), attr="SynErr"),
								args=[ast.Num(self.errorNr)],
								keywords=[],
							)
						)
					)
				yield rootIfNode
			elif isinstance(p, NodeIteration):
				p2 = p.sub
				assert isinstance(p2, Node)

				if isinstance(p2, NodeWeakTerminal):
					s1 = table.Expected(p2.next, self.curSy)
					s2 = table.Expected(p.next, self.curSy)

					cond = ast.Call(
						func=selfWeakSeparatorAST,
						args=[
							printTermName(p2.sym),
							self.NewCondSet(s1),
							self.NewCondSet(s2),
						],
						keywords=[],
					)

					s1 = set()
					if p2.up or p2.next is None:
						p2 = None
					else:
						p2 = p2.next
				else:
					s1 = table.First(p2)
					cond = self.GenCond(table, s1, p2)

				whileBody = list(self.GenCode(table, p2, s1))
				if not whileBody:
					whileBody.append(ast.Pass())
				yield ast.While(test=cond, body=whileBody, orelse=[])
			elif isinstance(p, NodeOption):
				s1 = table.First(p.sub)
				yield ast.If(
					test=self.GenCond(table, s1, p.sub),
					body=[
						*self.GenCode(table, p.sub, s1),
					],
					orelse=[],
				)

			if (
				not isinstance(p, NodeEmpty)
				and not isinstance(p, NodeSemAct)
				and not isinstance(p, NodeSynchronization)
			):
				for val in range(0, len(isChecked)):
					isChecked.discard(val)

			if p.up:
				break

			p = p.next

	def GenProductions(self, table: "Tab") -> typing.Iterator[ast.FunctionDef]:
		for sym in table.nonterminals:
			self.curSy = sym

			if sym.returnAttrs:
				if len(sym.returnAttrs) == 1:
					retType = sym.returnAttrs[0].type if sym.returnAttrs[0].type else None
					retVar = ast.Name(sym.returnAttrs[0].name)
				else:
					retType = ast.Tuple(els=[a.type for a in sym.returnAttrs])
					retVar = ast.Tuple(els=[ast.Name(a.name) for a in sym.returnAttrs])
			else:
				retType = noneAST
				retVar = None

			body = [*CopySourcePart(sym.semPos), *self.GenCode(table, sym.graph, set())]

			# Generate the function close
			if retVar is not None:
				body.append(ast.Return(value=retVar))

			yield ast.FunctionDef(
				name=sym.name,
				args=ast.arguments(
					posonlyargs=[],
					args=[
						selfArgAST,
						*[
							ast.arg(
								arg=a.name,
								annotation=(a.type if a.type else None)
							)
							for a in sym.attrs
						],
					],
					vararg=None,
					kwonlyargs=None,
					kw_defaults=None,
					kwarg=None,
					defaults=[],
				),
				body=body,
				decorator_list=[],
				returns=retType,
				type_comment=None,
			)

	def __init__(self) -> None:
		self.curSy = None  # symbol whose production is currently generated
		self.err = None  # generated parser error messages
		self.symSet = []

	def InitSets(self, table: "Tab", setsInitializerName: str = "_generateSet", setVarName: str = "set") -> typing.Tuple[ast.FunctionDef, ast.Assign]:
		TAST = ast.Name("T")
		xAST = ast.Name("x")
		res = []

		for i in range(0, len(self.symSet)):
			s = self.symSet[i]
			res.append(
				ast.Tuple(elts=[(TAST if sym.n in s else xAST) for sym in table.terminals]),
			)

		setsInitializerAST = ast.FunctionDef(
			name=setsInitializerName,
			args=ast.arguments(
				posonlyargs=[],
				args=[],
				vararg=None,
				kwonlyargs=[],
				kw_defaults=[],
				kwarg=None,
				defaults=[],
			),
			body=[
				ast.Assign(targets=[TAST], value=trueAST),
				ast.Assign(targets=[xAST], value=falseAST),
				ast.Return(ast.Tuple(elts=res)),
			],
			decorator_list=[],
			returns=genTypingUniformTuple(genTypingUniformTuple(ast.Name("bool"))),
			type_comment=None,
		)

		setsAssignAST = ast.Assign(
			targets=[ast.Name(setVarName)],
			value=ast.Call(func=ast.Name(setsInitializerName), args=[], keywords=[]),
			type_comment=None,
		)

		return setsInitializerAST, setsAssignAST

	def WriteParser(self, table: Tab, withNames: bool, preamble: typing.Optional[Preamble] = None, useAnnotatedAssignments: bool = False) -> ast.AST:
		assert isinstance(withNames, bool)
		assert isinstance(table.allSyncSets, set)
		self.symSet.append(table.allSyncSets)

		enumName = scannerEnumName
		baseClassName = baseParserClassName
		baseClassNameAST = ast.Name(baseClassName)
		myClassName = generatedParserClassName

		moduleSrc = []

		if preamble is None:
			preamble = Preamble()

		if not preamble.licenseHeaderText:
			preamble.licenseHeaderText = __gpl_exception_generated__

		if preamble.doc is not None:
			moduleSrc.append(ast.Expr(ast.Str(preamble.doc + "\n\n" + parserDocPostfix)))

		customImports = DefaultDictRestIter(preamble.imports)

		moduleSrc.extend((
			ast.Assign(
				targets=[ast.Name("__copyright__")],
				value=ast.Str(preamble.licenseHeaderText),
				type_comment=None,
			),
			*defaultParserSystemImports,
			*customImports["STDLIB"],

			*customImports["THIRDPARTY"],

			ast.ImportFrom(
				module=runtimeBasePackage + "." + runtimeParserModule,
				names=[ast.alias(name=baseClassName, asname=None)],
				level=0,
			),
			ast.ImportFrom(
				module=runtimeBasePackage + "." + runtimeScannerModule,
				names=[ast.alias(name="Position", asname=None)],
				level=0,
			),

			*customImports["FIRSTPARTY"],

			ast.ImportFrom(
				module=baseScannerClassName,
				names=[
					ast.alias(name=scannerEnumName, asname=None)
				],
				level=1
			),
			*customImports["LOCALFOLDER"],

			sum(tuple(customImports.values()), start=[]),
			*preamble.restOfPreamble,
		))

		self.err = []
		for sym in table.terminals:
			moduleSrc.append(self.GenErrorMsg(ParserErrorCodes.tErr, sym))

		parserClass = genClassStub(name=myClassName, baseClassNameAST=baseClassNameAST)
		parserClassBody = []  # fucking pylint

		enumNameAST = ast.Name(enumName)

		parserClassBody.extend((
			ast.Assign(
				targets=[ast.Name(enumTypeMemberName)],
				value=enumNameAST,
				type_comment=None,
			),
			ast.Assign(
				targets=[ast.Name(mainProductionNameMemberName)],
				value=ast.Str(table.gramSy.name),
				type_comment=None,
			),
			ast.Assign(
				targets=[ast.Name(eofSymbolMemberName)],
				value=printTermName(table.eofSy, enumNameAST),
				type_comment=None,
			),
		))

		parserClassBody.extend(CopySourcePart(table.semDeclPos, 0))
		parserClassBody.append(GenCodePragmas(table))
		parserClassBody.extend(self.GenProductions(table))

		setsInitializerAST, setsAssignAST = self.InitSets(table)
		moduleSrc.append(setsInitializerAST)
		parserClassBody.append(setsAssignAST)
		parserClassBody.append(
			ast.Assign(
				targets=[ast.Name(errorMessagesCollectionMemberName)],
				value=ast.Tuple(literalToAST(self.err).elts),
				type_comment=None,
			)
		)

		parserClass.body.extend(parserClassBody)  # pylint:disable=no-member
		moduleSrc.append(parserClass)

		return ast.Module(body=moduleSrc)

	def WriteStatistics(self, table: "Tab", io):
		print("Statistics:", file=io)
		print("-----------", file=io)
		print(file=io)
		print(str(len(table.terminals)) + " terminals", file=io)
		print(str(len(table.terminals) + len(table.pragmas) + len(table.nonterminals)) + " symbols", file=io)
		print(str(len(table.nodes)) + " nodes", file=io)
		print(str(len(self.symSet)) + " sets", file=io)
