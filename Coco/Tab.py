__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code

import typing

from CoCoRuntime.errors import Errors

from .charUtils import Unescape
from .Core import LL1ErrorCondition, UserDefinedTokenName, ll1ErrorsConditionsDescriptions
from .defaults import INDENT
from .nodes import Node, NodeAlternative, NodeAny, NodeEmpty, NodeIteration, NodeNonTerminal, NodeOption, NodeResolverExpr, NodeSynchronization, NodeTerminal, NodeWeakTerminal
from .symbols import Symbol, SymNonTerminal, SymPragma, SymTerminal
from .Trace import Trace


class Options:
	__slots__ = ("traceAutomaton", "firstAndFollow", "syntaxGraph", "traceComputations", "listAnyAndSync", "mergeErrors", "symbolTable", "crossReferences", "statistics", "testOnly", "tokenNames", "generateDriver")
	mapping = {k: i for i, k in enumerate(__slots__)}

	def __init__(self) -> None:
		self.traceAutomaton = self.firstAndFollow = self.syntaxGraph = self.traceComputations = self.listAnyAndSync = self.mergeErrors = self.symbolTable = self.crossReferences = self.statistics = self.testOnly = self.tokenNames = self.generateDriver = False  # fucking pylint


class Tab:
	__slots__ = ("semDeclPos", "ignored", "ddt", "gramSy", "eofSy", "noSym", "allSyncSets", "nsName", "frameDir", "literals", "visited", "curSy", "resOk", "nodes", "dummyNode", "nonterminals", "pragmas", "terminals", "trace")

	# ---------------------------------------------------------------------
	#  Symbol set computations
	# ---------------------------------------------------------------------

	def First0(self, p: typing.Optional[Node], mark: typing.Set[int]) -> typing.Set[int]:
		"""Computes the first set for the given Node."""
		assert isinstance(p, Node) or (p is None)
		assert isinstance(mark, set)
		fs = set()
		while p is not None and p.n not in mark:
			mark.add(p.n)
			if isinstance(p, NodeNonTerminal):
				if p.sym.firstReady:
					fs |= p.sym.first
				else:
					fs |= self.First0(p.sym.graph, mark)
			elif isinstance(p, (NodeTerminal, NodeWeakTerminal)):
				fs.add(p.sym.n)
			elif isinstance(p, NodeAny):
				fs |= p.set
			elif isinstance(p, NodeAlternative):
				fs |= self.First0(p.sub, mark)
				fs |= self.First0(p.down, mark)
			elif isinstance(p, (NodeIteration, NodeOption)):
				fs |= self.First0(p.sub, mark)
			if not p.DelNode():
				break
			p = p.next
		return fs

	def First(self, p: typing.Optional[Node]) -> typing.Set[int]:
		assert isinstance(p, Node) or (p is None)
		fs = self.First0(p, set())
		if self.ddt.traceComputations:
			self.trace.WriteLine()
			if p is not None:
				self.trace.WriteLine("First: node = " + str(p.n))
			else:
				self.trace.WriteLine("First: node = None")
			self.PrintSet(fs, 0)
		return fs

	def CompFirstSets(self) -> None:
		assert isinstance(self.nonterminals, list)
		nt = self.nonterminals
		for sym in nt:
			sym.first = set()
			sym.firstReady = False
		for sym in nt:
			sym.first = self.First(sym.graph)
			sym.firstReady = True

	def CompFollow(self, p: typing.Optional[Node]) -> None:
		assert isinstance(p, Node) or (p is None)
		assert isinstance(self.visited, set)
		while (p is not None) and (p.n not in self.visited):
			self.visited.add(p.n)
			if isinstance(p, NodeNonTerminal):
				s = self.First(p.next)
				p.sym.follow |= s
				if Node.DelGraph(p.next):
					p.sym.nts.add(self.curSy.n)
			elif isinstance(p, (NodeOption, NodeIteration)):
				self.CompFollow(p.sub)
			elif isinstance(p, NodeAlternative):
				self.CompFollow(p.sub)
				self.CompFollow(p.down)
			p = p.next

	def Complete(self, sym: SymNonTerminal) -> None:
		assert isinstance(sym, Symbol)
		if sym.n not in self.visited:
			self.visited.add(sym.n)
			nt = self.nonterminals
			for s in nt:
				if s.n in sym.nts:
					self.Complete(s)
					sym.follow |= s.follow
					if sym == self.curSy:
						sym.nts.discard(s.n)

	def CompFollowSets(self) -> None:
		nt = self.nonterminals
		for sym in nt:
			sym.follow = set()
			sym.nts = set()
		self.gramSy.follow.add(self.eofSy.n)
		self.visited = set()
		for sym in nt:
			self.curSy = sym
			self.CompFollow(sym.graph)
		for sym in nt:
			self.visited = set()
			self.curSy = sym
			self.Complete(sym)

	def LeadingAny(self, p: typing.Optional[Node]) -> typing.Optional[Node]:
		assert isinstance(p, Node) or (p is None)
		if p is None:
			return None
		a = None
		if isinstance(p, NodeAny):
			a = p
		elif isinstance(p, NodeAlternative):
			a = self.LeadingAny(p.sub)
			if a is None:
				a = self.LeadingAny(p.down)
		elif isinstance(p, (NodeOption, NodeIteration)):
			a = self.LeadingAny(p.sub)
		elif p.DelNode() and not p.up:
			a = self.LeadingAny(p.next)
		return a

	def FindAS(self, p: typing.Optional[Node]) -> None:
		"""find ANY sets"""
		assert isinstance(p, Node) or (p is None)
		while p is not None:
			if isinstance(p, (NodeOption, NodeIteration)):
				self.FindAS(p.sub)
				a = self.LeadingAny(p.sub)
				if a is not None:
					a.set -= self.First(p.next)
			elif isinstance(p, NodeAlternative):
				s1 = set()
				q = p
				while q is not None:
					self.FindAS(q.sub)
					a = self.LeadingAny(q.sub)
					if a is not None:
						h = self.First(q.down)
						h |= s1
						a.set -= h
					else:
						s1 |= self.First(q.sub)
					q = q.down
			if p.up:
				break
			p = p.next

	def CompAnySets(self) -> None:
		nt = self.nonterminals
		for sym in nt:
			self.FindAS(sym.graph)

	def Expected(self, p: typing.Optional[Node], curSy: Symbol) -> typing.Set[int]:
		assert isinstance(p, Node) or (p is None)
		assert isinstance(curSy, Symbol)
		s = self.First(p)
		if Node.DelGraph(p):
			s |= curSy.follow
		return s

	# does not look behind resolvers; only called during LL(1) test and in CheckRes
	def Expected0(self, p: Node, curSy: Symbol) -> typing.Set[int]:
		assert isinstance(p, Node)
		assert isinstance(curSy, Symbol)
		if isinstance(p, NodeResolverExpr):
			return set()
		return self.Expected(p, curSy)

	def CompSync(self, p: typing.Optional[Node]) -> None:
		assert isinstance(p, Node) or (p is None)
		while (p is not None) and (p.n not in self.visited):
			self.visited.add(p.n)
			if isinstance(p, NodeSynchronization):
				s = self.Expected(p.next, self.curSy)
				s.add(self.eofSy.n)
				self.allSyncSets |= s
				p.set = s
			elif isinstance(p, NodeAlternative):
				self.CompSync(p.sub)
				self.CompSync(p.down)
			elif isinstance(p, (NodeOption, NodeIteration)):
				self.CompSync(p.sub)
			p = p.next

	def CompSyncSets(self) -> None:
		nt = self.nonterminals
		self.allSyncSets = set()
		self.allSyncSets.add(self.eofSy.n)
		self.visited = set()
		for sym in nt:
			self.curSy = sym
			self.CompSync(self.curSy.graph)

	def SetupAnys(self) -> None:
		for p in self.nodes:
			if isinstance(p, NodeAny):
				p.set = set()
				for j in range(0, len(self.terminals)):
					p.set.add(j)
				p.set.discard(self.eofSy.n)

	def CompDeletableSymbols(self, errors: Errors) -> None:
		nt = self.nonterminals

		changed = False
		for sym in nt:
			if (not sym.deletable) and (sym.graph is not None) and Node.DelGraph(sym.graph):
				sym.deletable = True
				changed = True
		while changed:
			changed = False
			for sym in nt:
				if (not sym.deletable) and (sym.graph is not None) and Node.DelGraph(sym.graph):
					sym.deletable = True
					changed = True
		for sym in nt:
			if sym.deletable:
				errors.storeWarning(-1, -1, sym.name + " deletable")

	def RenumberPragmas(self) -> None:
		n = len(self.terminals)
		for sym in self.pragmas:
			sym.n = n
			n += 1

	def CompSymbolSets(self, errors: Errors) -> None:
		self.CompDeletableSymbols(errors)
		self.CompFirstSets()
		self.CompFollowSets()
		self.CompAnySets()
		self.CompSyncSets()
		if self.ddt.firstAndFollow:
			self.trace.WriteLine()
			self.trace.WriteLine("First & follow symbols:")
			self.trace.WriteLine("----------------------")
			self.trace.WriteLine()
			nt = self.nonterminals
			for sym in nt:
				self.trace.WriteLine(sym.name)
				self.trace.Write("first:   ")
				self.PrintSet(sym.first, 10)
				self.trace.Write("follow:  ")
				self.PrintSet(sym.follow, 10)
				self.trace.WriteLine()
		if self.ddt.listAnyAndSync:
			self.trace.WriteLine()
			self.trace.WriteLine("ANY and SYNC sets:")
			self.trace.WriteLine("-----------------")
			for p in self.nodes:
				if isinstance(p, (NodeAny, NodeSynchronization)):
					self.trace.Write(str(p.n), 4)
					self.trace.Write(" ")
					self.trace.Write(p.nTyp, 4)
					self.trace.Write(": ")
					self.PrintSet(p.set, 12)
					self.trace.WriteLine()

	# ---------------------------------------------------------------------
	#  Grammar checks
	# ---------------------------------------------------------------------

	def GrammarOk(self, errors: Errors) -> bool:
		ok = self.NtsComplete(errors) and self.AllNtReached(errors) and self.NoCircularProductions(errors) and self.AllNtToTerm(errors) and self.ResolversOk(errors)
		assert isinstance(ok, bool)
		if ok:
			self.CheckLL1(errors)
		return ok

	# --------------- check for circular productions ----------------------

	def GetSingles(self, p: typing.Optional[Node], singles: typing.List[SymNonTerminal]) -> None:
		assert isinstance(p, Node) or (p is None)
		assert isinstance(singles, list)
		if p is None:
			return  # end of graph
		if isinstance(p, NodeNonTerminal):
			if p.up or Node.DelGraph(p.next):
				singles.append(p.sym)
		elif isinstance(p, (NodeAlternative, NodeIteration, NodeOption)):
			if p.up or Node.DelGraph(p.next):
				self.GetSingles(p.sub, singles)
				if isinstance(p, NodeAlternative):
					self.GetSingles(p.down, singles)
		if (not p.up) and p.DelNode():
			self.GetSingles(p.next, singles)

	def NoCircularProductions(self, errors: Errors) -> bool:
		class CNode:
			"""node of list for finding circular productions"""

			def __init__(self, l, r):
				self.left = l
				self.right = r

		lst = []
		for sym in self.nonterminals:
			singles = []
			self.GetSingles(sym.graph, singles)  # get nonterminals s such that sym-->s
			for s in singles:
				lst.append(CNode(sym, s))

		changed = False
		i = 0
		while i < len(lst):
			n = lst[i]
			onLeftSide = False
			onRightSide = False
			for m in lst:
				if n.left == m.right:
					onRightSide = True
				if n.right == m.left:
					onLeftSide = True
			if (not onLeftSide) or (not onRightSide):
				lst.remove(n)
				i -= 1
				changed = True
			i += 1

		while changed:
			changed = False
			i = 0
			while i < len(lst):
				n = lst[i]
				onLeftSide = False
				onRightSide = False
				for m in lst:
					if n.left == m.right:
						onRightSide = True
					if n.right == m.left:
						onLeftSide = True
				if (not onLeftSide) or (not onRightSide):
					lst.remove(n)
					i -= 1
					changed = True
				i += 1

		ok = True
		if lst:
			ok = False
			errors.storeError(-1, -1, "circular production detected: " + ", ".join(("  " + n.left.name + " --> " + n.right.name) for n in lst))
		return ok

	# --------------- check for LL(1) errors ----------------------

	def LL1Error(self, cond: LL1ErrorCondition, sym: typing.Optional[Symbol], errors: Errors) -> None:
		assert isinstance(cond, int)
		assert isinstance(sym, Symbol) or (sym is None)
		msg = "  LL(1) warning in " + self.curSy.name + ": "
		if sym is not None:
			msg += sym.name + " is "

		errors.Warn(-1, -1, msg + ll1ErrorsConditionsDescriptions[cond])

	def CheckOverlap(self, s1: typing.Set[int], s2: typing.Set[int], cond: LL1ErrorCondition, errors: Errors) -> None:
		assert isinstance(s1, set)
		assert isinstance(s2, set)
		assert isinstance(cond, int)
		for sym in self.terminals:
			if (sym.n in s1) and (sym.n in s2):
				self.LL1Error(cond, sym, errors)

	def CheckAlts(self, p: Node, errors: Errors) -> None:
		assert isinstance(p, Node)
		while p is not None:
			if isinstance(p, NodeAlternative):
				q = p
				s1 = set()
				while q is not None:  # for all alternatives
					s2 = self.Expected0(q.sub, self.curSy)
					self.CheckOverlap(s1, s2, LL1ErrorCondition.severalAlts, errors)
					s1 |= s2
					self.CheckAlts(q.sub, errors)
					q = q.down
			elif isinstance(p, (NodeOption, NodeIteration)):
				if Node.DelSubGraph(p.sub):
					self.LL1Error(LL1ErrorCondition.severalAlts, None, errors)  # e.g. [[...]]
				else:
					s1 = self.Expected0(p.sub, self.curSy)
					s2 = self.Expected(p.next, self.curSy)
					self.CheckOverlap(s1, s2, LL1ErrorCondition.isDeleteable, errors)
				self.CheckAlts(p.sub, errors)
			elif isinstance(p, NodeAny):
				if len(p.set) == 0:
					self.LL1Error(LL1ErrorCondition.anyDoesntMatch, None, errors)
				# e.g. {ANY} ANY or [ANY] ANY
			if p.up:
				break
			p = p.next

	def CheckLL1(self, errors: Errors) -> None:
		for sym in self.nonterminals:
			self.curSy = sym
			self.CheckAlts(self.curSy.graph, errors)

	# ------------- check if resolvers are legal  --------------------

	def ResErr(self, p: Node, msg: str, errors: Errors) -> None:
		assert isinstance(p, Node)
		assert isinstance(msg, str)
		errors.storeError(p.line, p.pos.col, msg)
		self.resOk = False

	def CheckRes(self, p: Node, rslvAllowed: bool, errors: Errors) -> None:
		assert isinstance(p, Node)
		assert isinstance(rslvAllowed, bool)
		while p is not None:
			if isinstance(p, NodeAlternative):
				expected = set()
				q = p
				while q is not None:
					expected |= self.Expected0(q.sub, self.curSy)
					q = q.down
				soFar = set()
				q = p
				while q is not None:
					if isinstance(q.sub, NodeResolverExpr):
						fs = self.Expected(q.sub.next, self.curSy)
						if fs.intersection(soFar):
							self.ResErr(q.sub, "Resolver will never be evaluated. " "Place it at previous conflicting alternative.", errors)
						if not fs.intersection(expected):
							self.ResErr(q.sub, "Misplaced resolver: no LL(1) conflict.", errors)
					else:
						soFar |= self.Expected(q.sub, self.curSy)
					self.CheckRes(q.sub, True, errors)

					q = q.down
			elif isinstance(p, (NodeIteration, NodeOption)):
				if isinstance(p.sub, NodeResolverExpr):
					fs = self.First(p.sub.next)
					fsNext = self.Expected(p.next, self.curSy)
					if not fs.intersection(fsNext):
						self.ResErr(p.sub, "Misplaced resolver: no LL(1) conflict.", errors)
				self.CheckRes(p.sub, True, errors)
			elif isinstance(p, NodeResolverExpr):
				if not rslvAllowed:
					self.ResErr(p, "Misplaced resolver: no alternative.", errors)
			if p.up:
				break
			p = p.next
			rslvAllowed = False

	def ResolversOk(self, errors: Errors) -> bool:
		self.resOk = True
		for sym in self.nonterminals:
			self.curSy = sym
			self.CheckRes(self.curSy.graph, False, errors)
		return self.resOk

	# ------------- check if every nts has a production --------------------

	def NtsComplete(self, errors: Errors) -> bool:
		complete = True
		for sym in self.nonterminals:
			if sym.graph is None:
				complete = False
				errors.storeError(-1, -1, "No production for " + sym.name)
		return complete

	# -------------- check if every nts can be reached  -----------------

	def MarkReachedNts(self, p: typing.Optional[Node]) -> None:
		assert isinstance(p, Node) or (p is None)
		while p is not None:
			if isinstance(p, NodeNonTerminal) and (p.sym.n not in self.visited):  # new nt reached
				self.visited.add(p.sym.n)
				self.MarkReachedNts(p.sym.graph)
			elif isinstance(p, (NodeAlternative, NodeIteration, NodeOption)):
				self.MarkReachedNts(p.sub)
				if isinstance(p, NodeAlternative):
					self.MarkReachedNts(p.down)
			if p.up:
				break
			p = p.next

	def AllNtReached(self, errors: Errors) -> bool:
		ok = True
		self.visited = set()
		self.visited.add(self.gramSy.n)
		self.MarkReachedNts(self.gramSy.graph)
		for sym in self.nonterminals:
			if sym.n not in self.visited:
				ok = False
				errors.storeError(-1, -1, sym.name + " cannot be reached")
		return ok

	# --------- check if every nts can be derived to terminals  ------------

	def IsTerm(self, p: Node, mark: typing.Set[int]) -> bool:
		"""true if graph can be derived to terminals"""
		assert isinstance(p, Node)
		assert isinstance(mark, set)
		while p is not None:
			if isinstance(p, NodeNonTerminal) and (p.sym.n not in mark):
				return False
			if isinstance(p, NodeAlternative) and not self.IsTerm(p.sub, mark) and ((p.down is None) or not self.IsTerm(p.down, mark)):
				return False
			if p.up:
				break
			p = p.next
		return True

	def AllNtToTerm(self, errors: Errors) -> bool:
		ok = True
		mark = set()
		# a nonterminal is marked if it can be derived to terminal symbols

		changed = False
		for sym in self.nonterminals:
			if (sym.n not in mark) and self.IsTerm(sym.graph, mark):
				mark.add(sym.n)
				changed = True

		while changed:
			changed = False
			for sym in self.nonterminals:
				if (sym.n not in mark) and self.IsTerm(sym.graph, mark):
					mark.add(sym.n)
					changed = True

		for sym in self.nonterminals:
			if sym.n not in mark:
				ok = False
				errors.storeError(-1, -1, "cannot be derived to terminals")
		return ok

	# ---------------------------------------------------------------------
	#  Utility functions
	# ---------------------------------------------------------------------

	@staticmethod
	def Num(p):
		if p is None:
			return 0
		return p.n

	def PrintSet(self, aSet, indent):
		assert isinstance(indent, int)

		col = indent

		for sym in self.terminals:
			if sym.n in aSet:
				ln = len(sym.name)
				if col + ln >= 80:
					self.trace.WriteLine()
					col = 1
					while col < indent:
						self.trace.Write(" ")
						col += 1
				self.trace.Write(sym.name + " ")
				col += ln + 1
		if col == indent:
			self.trace.Write("-- empty set --")
		self.trace.WriteLine()

	tKind = ["fixedToken   ", "classToken   ", "litToken     ", "classLitToken"]

	def PrintSym(self, sym):
		assert isinstance(sym, Symbol)
		self.trace.Write(str(sym.n), 3)
		self.trace.Write(" ")
		self.trace.Write(Node.Name(sym.name), -14)
		self.trace.Write(" ")
		self.trace.Write(Symbol.nTyp[sym.typ], 2)
		if sym.attrPos is None:
			self.trace.Write(" false ")
		else:
			self.trace.Write(" true  ")
		if isinstance(sym, SymNonTerminal):
			self.trace.Write(str(self.Num(sym.graph)), 5)
			if sym.deletable:
				self.trace.Write(" true  ")
			else:
				self.trace.Write(" false ")
		else:
			self.trace.Write(INDENT * 4 + "")
		self.trace.Write(str(sym.line), 5)
		self.trace.Write(" " + self.tKind[sym.tokenKind].strip())
		if isinstance(sym, (SymNonTerminal, SymPragma)) and (sym.symName is not None):
			self.trace.Write(INDENT + sym.symName)
		self.trace.WriteLine()

	def PrintSymbolTable(self):
		self.trace.WriteLine("Symbol Table:")
		self.trace.WriteLine("------------")
		self.trace.WriteLine()
		self.trace.WriteLine(" nr name          typ  hasAt graph  del    line tokenKind")
		for sym in self.terminals:
			self.PrintSym(sym)
		for sym in self.pragmas:
			self.PrintSym(sym)
		for sym in self.nonterminals:
			self.PrintSym(sym)
		self.trace.WriteLine()
		self.trace.WriteLine("Literal Tokens:")
		self.trace.WriteLine("--------------")
		for me_key, me_value in sorted(self.literals.items()):
			self.trace.WriteLine("_" + me_value.name + " = " + me_key + ".")
		self.trace.WriteLine()

	def XRef(self):
		tab = {}
		for sym in self.nonterminals:
			if sym in tab:
				lst = tab[sym]
			else:
				lst = []
				tab[sym] = lst
			lst.append(-sym.line)

		# collect lines where symbols have been referenced
		for n in self.nodes:
			if isinstance(n, (NodeTerminal, NodeWeakTerminal, NodeNonTerminal)):
				if n.sym in tab:
					lst = tab[n.sym]
				else:
					lst = []
					tab[n.sym] = lst
				lst.append(n.line)

		# print cross reference list
		self.trace.WriteLine("Cross reference list:")
		self.trace.WriteLine("--------------------")
		self.trace.WriteLine()
		keyList = sorted([x.name for x in list(tab.keys())])
		for key in keyList:
			for k in list(tab.keys()):
				if k.name == key:
					sym = k
					break

			self.trace.Write("  ")
			self.trace.Write(Node.Name(sym.name), -12)
			lst = tab[sym]
			col = 14
			for line in lst:
				if col + 5 > 80:
					self.trace.WriteLine()
					for col in range(1, 15):
						self.trace.Write(" ")
				self.trace.Write(str(line), 5)
				col += 5
			self.trace.WriteLine()
		self.trace.WriteLine()
		self.trace.WriteLine()

	def DeleteNodes(self) -> None:
		self.nodes = []
		self.dummyNode = NodeEmpty(self)

	def __init__(self) -> None:
		self.nonterminals = []
		self.pragmas = []
		self.terminals = []

		self.DeleteNodes()  # initializes

		self.trace = Trace()

		self.semDeclPos = None  # Position,   position of global semantic declarations
		self.ignored = None  # Set,   characters ignored by the scanner
		self.ddt = Options()  # boolean[20],  debug and test switches
		self.gramSy = None  # Symbol,   root nonterminal; filled by ATG
		self.eofSy = SymTerminal(self, "EOF", 0, None)  # Symbol,   end of file symbol
		self.noSym = None  # Symbol,   used in case of an error
		self.allSyncSets = None  # set,   union of all synchronisation sets
		self.nsName = ""  # namespace for generated files
		self.frameDir = None  # directory containing the frame files
		self.literals = {}  # Hashtable,   symbols that are used as literals

		self.visited = None  # set,   mark list for graph traversals
		self.curSy = None  # Symbol,   current symbol in computation of sets
		self.resOk = False

	# considerable extension from here on to handle name generation

	@staticmethod
	def NewName(alias, name, errors: Errors):
		assert isinstance(alias, str)
		assert isinstance(name, str)
		if name.find(" ") >= 0:
			errors.storeError(-1, -1, "tokens must not contain blanks")
		UserDefinedTokenName(alias, name)

	@staticmethod
	def Ascii(ch: str) -> str:
		assert isinstance(ch, str)
		name = {chr(0): "nul", chr(1): "soh", chr(2): "stx", chr(3): "etx", chr(4): "eot", chr(5): "enq", chr(6): "ack", chr(7): "bel", chr(8): "bs", chr(9): "ht", chr(10): "lf", chr(11): "vt", chr(12): "ff", chr(13): "cr", chr(14): "so", chr(15): "si", chr(16): "dle", chr(17): "dc1", chr(18): "dc2", chr(19): "dc3", chr(20): "dc4", chr(21): "nak", chr(22): "syn", chr(23): "etb", chr(24): "can", chr(25): "em", chr(26): "sub", chr(27): "esc", chr(28): "fs", chr(29): "gs", chr(30): "rs", chr(31): "us", " ": "_", "!": "bang", '"': "dquote", "#": "hash", "$": "dollar", "%": "percent", "&": "and", "'": "squote", "(": "lparen", ")": "rparen", "*": "star", "+": "plus", ",": "comma", "-": "minus", ".": "point", "/": "slash", "0": "d0", "1": "d1", "2": "d2", "3": "d3", "4": "d4", "5": "d5", "6": "d6", "7": "d7", "8": "d8", "9": "d9", ":": "colon", ";": "semicolon", "<": "less", "=": "equal", ">": "greater", "?": "query", "@": "at", "[": "lbrack", "\\": "backslash", "]": "rbrack", "^": "uparrow", "_": "underscore", "`": "accent", "{": "lbrace", "|": "bar", "}": "rbrace", "~": "tilde", chr(127): "delete"}
		if ch in name:
			return name[ch]
		return "ASC" + str(ch)

	def SymName(self, name: str, errors: Errors) -> str:
		assert isinstance(name, str)
		name = str(name)
		for u in UserDefinedTokenName.NameTab:
			if name == u.name:
				return u.alias
		if name[0] == '"':
			name = Unescape(name[1:-1], errors)

		S = [None] * (len(name) + 1)
		S[-1] = "_Sym"

		ch = name[0]
		if "a" <= ch <= "z" or "A" <= ch <= "Z":
			S[0] = ch
		else:
			S[0] = self.Ascii(ch)

		for i, ch in enumerate(name[1:], 1):
			if "a" <= ch <= "z" or "A" <= ch <= "Z" or "0" <= ch <= "9":
				S[i] = ch
			else:
				S[i] = self.Ascii(ch)

		return "".join(S)

	def findSymbol(self: "Tab", name: str) -> typing.Optional["Symbol"]:
		assert isinstance(name, str)

		for s in self.terminals:
			if s.name == name:
				return s

		for s in self.nonterminals:
			if s.name == name:
				return s

		return None

	def AssignNames(self, errors: Errors) -> None:
		for sym in self.terminals:
			sym.symName = self.SymName(sym.name, errors)
		for sym in self.pragmas:
			sym.symName = self.SymName(sym.name, errors)
		self.terminals[0].symName = "EOF_SYM"
		self.terminals[len(self.terminals) - 1].symName = "NOT_SYM"
