__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code


import typing
from abc import ABC, abstractmethod

from .CharClass import CharClass
from .defaults import INDENT
from .symbols import Symbol, SymNonTerminal, SymTerminal
from .Trace import Trace


class Node(ABC):
	__slots__ = ("n", "next", "up", "val", "code", "set", "pos", "line", "state")

	nodes = []

	def __init__(self, table: "Tab", line: typing.Optional[int] = None) -> None:
		self.n = len(table.nodes)  # node number
		self.next = None  # Node,   to successor node
		self.up = False  # true: "next" leads to successor in enclosing structure
		#             sem:       pos of semantic action in source text
		self.line = 0  # source text line number of item in this node
		self.state = None  # State,   DFA state corresponding to this node
		#          (only used in DFA.ConvertToStates)

		if isinstance(line, int):
			self.line = line
		else:
			self.line = 0

		table.nodes.append(self)

	@staticmethod
	def DelGraph(p: typing.Optional["Node"]) -> bool:
		return (p is None) or p.DelNode() and Node.DelGraph(p.next)

	@staticmethod
	def DelSubGraph(p: typing.Optional["Node"]) -> bool:
		return p is None or p.DelNode() and (p.up or Node.DelSubGraph(p.next))

	@abstractmethod
	def DelNode(self) -> bool:
		raise NotImplementedError

	# ----------------- for printing ----------------------

	@staticmethod
	def Ptr(p, up):
		assert isinstance(p, Node) or (p is None)
		assert isinstance(up, bool)
		if p is None:
			return 0
		if up:
			return -p.n
		return p.n

	@staticmethod
	def Pos(pos):
		if pos is None:
			return INDENT + "  "
		return Trace.formatString(str(pos.beg), 5)

	@staticmethod
	def Name(name):
		assert isinstance(name, str)
		return (name + INDENT * 3 + "  ")[0:12]
		# found no simpler way to get the first 12 characters of the name
		# padded with blanks on the right

	def _trace(self, trace: Trace):
		pass

	@staticmethod
	def PrintNodes(graph: "Graph", trace: Trace):
		trace.WriteLine("Graph nodes:")
		trace.WriteLine("----------------------------------------------------")
		trace.WriteLine(INDENT + "n type name          next  down   sub   pos  line")
		trace.WriteLine(INDENT * 10 + "       val  code")
		trace.WriteLine("----------------------------------------------------")

		for p in graph.nodes:
			trace.Write(str(p.n), 4)
			trace.Write(" " + Node.nTyp[p.typ] + " ")
			if p.sym is not None:
				trace.Write(Node.Name(p.sym.name), 12)
				trace.Write(" ")
			elif isinstance(p, NodeCharClass):
				c = CharClass.classes[p.val]
				trace.Write(Node.Name(c.name), 12)
				trace.Write(" ")
			else:
				trace.Write(INDENT * 4 + " ")

			trace.Write(str(Node.Ptr(p.next, p.up)), 5)
			trace.Write(" ")

			p._trace(trace)
			trace.WriteLine(str(p.line), 5)

		trace.WriteLine()


class ContainerNode(Node):
	__slots__ = ("sub", "down")

	def __init__(self, table: "Tab", symOrNodeOrInt: typing.Optional[typing.Union[int, "Node", "Symbol"]], line: typing.Optional[int] = None) -> None:
		assert symOrNodeOrInt is None or isinstance(symOrNodeOrInt, (Symbol, Node, int))
		assert line is None or isinstance(line, int)
		#assert symOrNodeOrInt is None or isinstance(symOrNodeOrInt, int) or (isinstance(symOrNodeOrInt, Symbol) and typ == symOrNodeOrInt.typ) or isinstance(symOrNodeOrInt, __class__), (symOrNodeOrInt, typ, symOrNodeOrInt.typ)
		super().__init__(table, line)
		self.down = None  # Node,   alt: to next alternative
		self.sub = symOrNodeOrInt  # Node,   alt, iter, opt: to first node of substructure

	def _trace(self, trace: Trace, p):
		trace.Write(str(Node.Ptr(p.down, False)), 5)
		trace.Write(" ")
		trace.Write(str(Node.Ptr(p.sub, False)), 5)
		trace.Write(INDENT * 2 + " ")

	def DelNode(self) -> bool:
		return True


class NodeAlternative(ContainerNode):
	__slots__ = ()
	nTyp = "alt "

	@classmethod
	def DelAlt(cls, p: typing.Optional["Node"]) -> bool:
		return p is None or p.DelNode() and (p.up or cls.DelAlt(p.next))

	def DelNode(self) -> bool:
		return NodeAlternative.DelAlt(self.sub) or self.down is not None and self.__class__.DelAlt(self.down)


class NodeIteration(ContainerNode):
	__slots__ = ()
	nTyp = "iter"


class NodeOption(ContainerNode):
	__slots__ = ()
	nTyp = "opt "


class SymbolNode(Node):
	__slots__ = ("sym", "attrs", "returnAttrs")

	def __init__(self, table: "Tab", symOrNodeOrInt: typing.Optional[typing.Union[int, "Node", "Symbol"]], line: typing.Optional[int] = None) -> None:
		super().__init__(table, line)
		self.sym = None  # Symbol,   nt, t, wt: symbol represented by this node
		self.attrs = None  # Position,   nt, t, wt: pos of actual attributes
		self.returnAttrs = None  # str, nt: name of output attribute (or None)

		if isinstance(symOrNodeOrInt, int):
			self.val = symOrNodeOrInt
		else:
			self.sym = symOrNodeOrInt

	def _trace(self, trace: Trace, p):
		trace.Write(" \t\t\t\t")
		trace.Write(Node.Pos(p.pos), 5)

	def DelNode(self) -> bool:
		return False


class NodeTerminal(SymbolNode):
	__slots__ = ()
	nTyp = SymTerminal.nTyp


class NodeWeakTerminal(SymbolNode):
	__slots__ = ()
	nTyp = "wt  "


class NodeNonTerminal(SymbolNode):
	__slots__ = ()
	nTyp = SymNonTerminal.nTyp

	def DelNode(self) -> bool:
		return self.sym.deletable


class NodeAlphabet(Node):
	__slots__ = ("val", "code")

	def __init__(self, table: "Tab", symOrNodeOrInt: typing.Optional[typing.Union[int, "Node", "Symbol"]], line: typing.Optional[int] = None) -> None:
		self.val = 0  # chr:  ordinal character value
		# clas: index of character class
		self.code = 0  # chr, clas: transition code

		super().__init__(table, line)

	def _trace(self, trace: Trace, p):
		trace.Write(str(p.code), 5)
		trace.Write(INDENT * 2 + " ")

	def DelNode(self) -> bool:
		return False


class NodeCharacter(NodeAlphabet):
	__slots__ = ()
	nTyp = "chr "

	def __init__(self, table: "Tab", charOrd: int, line: int) -> None:
		super().__init__(table, line)
		self.val = charOrd

	def _trace(self, trace: Trace, p):
		trace.Write(str(p.val), 5)
		trace.Write(" ")
		super()._trace(trace, p)


class NodeCharClass(NodeAlphabet):
	__slots__ = ()
	nTyp = "clas"

	def __init__(self, table: "Tab", val: int, line: int) -> None:
		super().__init__(table, line)
		self.val = val

	def _trace(self, trace: Trace, p):
		trace.Write(INDENT * 2 + "")
		super()._trace(trace, p)

	def DelNode(self) -> bool:
		return False


class _NodeSet(Node):  # pylint:disable=abstract-method
	__slots__ = ()

	def __init__(self, table: "Tab", line: int = 0) -> None:
		super().__init__(table, line)
		self.val = None

	def _trace(self, trace: Trace, p):
		trace.Write(INDENT * 6 + "")


class NodeSet(_NodeSet):  # pylint:disable=abstract-method
	__slots__ = ()

	def __init__(self, table: "Tab", symOrNodeOrInt: typing.Optional[typing.Union[int, "Node", "Symbol"]], line: int):
		self.set = None  # set,   any, sync: the set represented by this node
		super().__init__(table, line)


class NodeSynchronization(_NodeSet):
	__slots__ = ()
	nTyp = "sync"

	def DelNode(self) -> bool:
		return True


class NodeAny(_NodeSet):
	__slots__ = ()
	nTyp = "any "

	def DelNode(self) -> bool:
		return False


class NodeEmpty(_NodeSet):
	__slots__ = ()
	nTyp = "eps "

	def DelNode(self) -> bool:
		return True


class NodeSemAct(Node):
	__slots__ = ()
	nTyp = "sem "

	def _trace(self, graph: "Graph", trace: Trace, p):
		trace.Write(INDENT * 4 + " ")
		trace.Write(Node.Pos(p.pos), 5)

	def DelNode(self) -> bool:
		return True


class NodeResolverExpr(Node):
	__slots__ = ()
	nTyp = "rslv"

	def __init__(self, table: "Tab", line: int):
		super().__init__(table, line)
		self.val = None

	def DelNode(self) -> bool:
		return True
