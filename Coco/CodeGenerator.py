__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code

import ast
import typing

from CoCoRuntime.scanner import Position

from .defaults import baseScannerClassName, enumTypeMemberName, eofSymbolEnumMemberName, invalidSymbolEnumMemberName
from .symbols import Symbol
from .utils import IndentSizer, deindent, getArrayTypeCode

sctx = ast.Store()
noneAST = ast.Constant(value=None, kind=None)
trueAST = ast.Num(True)
falseAST = ast.Num(False)
ellipsisAST = ast.Constant(value=Ellipsis, kind=None)
intAST = ast.Name(id="int")

ordAST = ast.Name("ord")
selfNameAST = ast.Name("self")
selfClassAST = ast.Attribute(value=selfNameAST, attr="__class__")
selfArgAST = ast.arg(arg="self", annotation=None, type_comment=None)
selfLaKindAST = ast.Attribute(value=ast.Attribute(value=selfNameAST, attr="la"), attr="kind")
selfGetCallAST = ast.Expr(ast.Call(func=ast.Attribute(value=selfNameAST, attr="Get"), args=[], keywords=[]))
selfSynErrAST = ast.Attribute(value=selfNameAST, attr="SynErr")
selfExpectAST = ast.Attribute(value=selfNameAST, attr="Expect")
typingAST = ast.Name(id="typing")


def sequenceAST(valueT: ast.AST) -> ast.Subscript:
	return ast.Subscript(
		value=ast.Attribute(value=typingAST, attr="Sequence"),
		slice=ast.Index(value=valueT),
	)


intCollectionAnnotationAST = sequenceAST(intAST)


def enumClassFieldTypeAnotationAST(enumName: str):
	return ast.Subscript(
		value=ast.Attribute(value=typingAST, attr="Type"),
		slice=ast.Index(value=ast.Str(value=enumName)),
	)


def genTypingUniformTuple(itemType: ast.AST) -> ast.Subscript:
	return ast.Subscript(
		value=ast.Attribute(value=typingAST, attr="Tuple"),
		slice=ast.Index(
			value=ast.Tuple(elts=[itemType, ellipsisAST]),
		),
	)


def genSelfExpectCall(*args) -> ast.Expr:
	return ast.Expr(ast.Call(
		func=selfExpectAST,
		args=list(args),
		keywords=[],
	))


selfExpectWeakAST = ast.Attribute(value=selfNameAST, attr="ExpectWeak")
selfWeakSeparatorAST = ast.Attribute(value=selfNameAST, attr="WeakSeparator")
selfNextChAST = ast.Attribute(value=selfNameAST, attr="NextCh")
selfNextChCallAST = ast.Expr(ast.Call(func=selfNextChAST, args=[], keywords=[]))
selfOldEolsAST = ast.Attribute(value=selfNameAST, attr="oldEols")
selfTAST = ast.Attribute(value=selfNameAST, attr="t")
selfPosAST = ast.Attribute(value=selfNameAST, attr="pos")
selfBufferAST = ast.Attribute(value=selfNameAST, attr="buffer")
scannerEnumAST = ast.Attribute(value=selfClassAST, attr=enumTypeMemberName)
scannerEnumNoSymAST = ast.Attribute(value=scannerEnumAST, attr=invalidSymbolEnumMemberName)
levelAST = ast.Name("level")
incLevelAST = ast.AugAssign(target=levelAST, op=ast.Add(), value=ast.Num(1))
decLevelAST = ast.AugAssign(target=levelAST, op=ast.Sub(), value=ast.Num(1))
levelEq0Test = ast.Compare(left=levelAST, ops=[ast.Eq()], comparators=[ast.Num(0)])
selfLineStartAST = ast.Attribute(value=selfNameAST, attr="lineStart")
selfLineAST = ast.Attribute(value=selfNameAST, attr="line")
scannerEOLAST = ast.Attribute(value=ast.Name(baseScannerClassName), attr="EOL")
doneAST = ast.Name("done")
selfChAST = ast.Attribute(value=selfNameAST, attr="ch")
selfTAST = ast.Attribute(value=selfNameAST, attr="t")
selfTValAST = ast.Attribute(value=selfTAST, attr="val")
selfTKindAST = ast.Attribute(value=selfTAST, attr="kind")
selfTValAssignBufAST = ast.Assign(targets=[selfTValAST], value=ast.Name("buf"), type_comment=None)
line0AST = ast.Name("line0")
stateAST = ast.Name("state")
bufferAST = ast.Name("Buffer")
bufferEOFAST = ast.Attribute(value=bufferAST, attr="EOF")
apxAST = ast.Name("apx")
litAST = ast.Name("lit")
bufAST = ast.Name("buf")
valChAST = ast.Name("valCh")
lineStart0AST = ast.Name("lineStart0")
selfCheckLiteralAST = ast.Attribute(value=selfNameAST, attr="CheckLiteral")
selfCheckLiteralCallAST = ast.Call(func=selfCheckLiteralAST, args=[], keywords=[])
selfCheckLiteralAssignCallAST = ast.Assign(targets=[selfTKindAST], value=selfCheckLiteralCallAST, type_comment=None)
arrayArrayAST = ast.Attribute(value=ast.Name(id="array"), attr="array")


def genArrayArrayCall(bodyAST: ast.AST, maxItem: int, unsigned: bool = True) -> ast.Call:
	typeCode = getArrayTypeCode(maxItem, unsigned)
	return ast.Call(
		func=arrayArrayAST,
		args=[
			ast.Str(typeCode),
			bodyAST,
		],
		keywords=[],
	)


def genSelfSynErrCall(errorNum: int) -> ast.Expr:
	return ast.Expr(ast.Call(
		func=selfSynErrAST,
		args=[ast.Num(errorNum)],
		keywords=[],
	))


def genSelfLaKindComp(right: typing.Union[ast.Constant, ast.Attribute]) -> ast.Compare:
	return ast.Compare(
		left=selfLaKindAST,
		ops=[ast.Eq()],
		comparators=[right],
	)


def genStartOfCall(*args) -> ast.Call:
	return ast.Call(func=ast.Attribute(value=selfNameAST, attr="StartOf"), args=list(args), keywords=[])


def prepareCheckCondition(ch: typing.Union[str, int]) -> typing.Tuple[typing.Union[ast.Attribute, ast.Call], ast.Constant, bool]:
	if isinstance(ch, str):
		ch = ord(ch)

	left = ast.Attribute(value=ast.Name("self"), attr="ch")

	isOrd = ch < ord(" ") or ch >= 127 or ch == ord("'") or ch == ord("\\")

	if isOrd:
		left = ast.Call(func=ast.Name("ord"), args=[left], keywords=[])
		right = ast.Num(ch)
	else:
		right = ast.Str(chr(ch))

	return left, right, isOrd


def ChCond(ch: typing.Union[str, int], relOpClass: typing.Type[ast.cmpop] = ast.Eq) -> ast.Compare:
	left, right, _ = prepareCheckCondition(ch)

	return ast.Compare(left=left, ops=[relOpClass()], comparators=[right])


def inRangeTestGenAST(lo: int, hi: int) -> typing.Union[ast.BoolOp, ast.Compare]:
	middleLo, left, isOrdLo = prepareCheckCondition(lo)  # self.ch, lo
	middleHi, right, isOrdHi = prepareCheckCondition(hi)  # self.ch, hi

	if isOrdLo == isOrdHi:
		return ast.Compare(
			left=left,
			ops=[ast.LtE(), ast.LtE()],
			comparators=[middleHi, right],
		)

	return ast.BoolOp(op=ast.And(), values=[
		ast.Compare(left=left, ops=[ast.LtE()], comparators=[middleLo]),
		ast.Compare(left=middleHi, ops=[ast.LtE()], comparators=[right]),
	])


def printTermName(sym: Symbol, enumToTakeFrom: typing.Optional[ast.Name] = None) -> typing.Union[ast.Constant, ast.Attribute]:
	#assert isinstance(sym, Symbol)
	assert isinstance(sym.symName, str) or (sym.symName is None)
	if sym.symName is None:
		return ast.Num(sym.n)

	if enumToTakeFrom is None:
		enumToTakeFrom = scannerEnumAST
	return ast.Attribute(value=enumToTakeFrom, attr=sym.symName)


def getSourcePart(pos: typing.Optional[Position]) -> str:
	# this `pos.col` is inconsistently badly wrong, so it is easier to compute from scratch rather than to fix this piece of shit risking to break it somewhere where it relies on this behavior
	beg = pos.beg
	end = pos.beg + pos.len

	indentSizer = IndentSizer(tabSize=4)

	while beg > 0 and pos.buf.buf[beg - 1] != "\n":
		beg -= 1

	col = 0
	for c in pos.buf.buf[beg : pos.beg]:
		col += indentSizer(c, col, lambda col: 1)

	src = pos.buf.buf[pos.beg : end]
	src = deindent(src, indentSizer, col)
	return src


def CopySourcePart(pos: typing.Optional[Position], forceOutput: bool = False) -> typing.Any:
	if pos is None:
		if forceOutput:
			return ast.Pass()

		return ()

	src = getSourcePart(pos)
	parsed = ast.parse(src, mode="exec", type_comments=True)
	res = parsed.body
	return res


def conditionFromSourcePart(pos: typing.Optional[Position], forceOutput: bool = False):
	return singleExprFromSourcePart(pos, forceOutput)


def singleExprFromSourcePart(pos: typing.Optional[Position], forceOutput: bool = False) -> ast.Expression:
	assert not forceOutput
	assert pos is not None
	return ast.parse(getSourcePart(pos), mode="eval", type_comments=True)


def funcArgsDefinitionFromSourcePart(pos: typing.Optional[Position]) -> ast.arguments:
	if pos is not None:
		src = getSourcePart(pos)
	else:
		src = ""
	funcSrc = "def a(" + src + "): pass"
	parsed = ast.parse(funcSrc, mode="exec", type_comments=True).body
	if len(parsed) != 1:
		raise ValueError("Not valid args", src)
	return parsed[0].args


def callArgsFromSourcePart(pos: typing.Optional[Position], forceOutput: bool = False) -> typing.List[ast.Expression]:
	if pos is None:
		return []

	expr = singleExprFromSourcePart(pos, forceOutput)
	if isinstance(expr, ast.Tuple):
		return expr.elts

	return [expr]


def GenTokens(table: "Tab", withNames: bool) -> typing.Iterator[ast.Assign]:
	assert isinstance(withNames, bool)
	#self.codeGen.write(INDENT + "# terminals\n")
	yield ast.Assign(targets=[ast.Name("maxT")], value=ast.Num(len(table.terminals) - 1))

	for sym in table.terminals:
		if sym.name[0].isalpha():
			yield ast.Assign(targets=[ast.Name("_" + sym.name)], value=ast.Num(sym.n))
		if withNames:
			yield ast.Assign(targets=[ast.Name(sym.symName)], value=ast.Num(sym.n))


def GenPragmas(table: "Controller", withNames: bool) -> typing.Iterator[ast.Assign]:
	for sym in table.pragmas:
		yield ast.Assign(targets=[ast.Name("_" + str(sym.name))], value=ast.Num(sym.n))
		if withNames:
			yield ast.Assign(targets=[ast.Name(sym.symName)], value=ast.Num(sym.n))


def genScannerEnum(name: str, table: "Tab", withNames: bool = True) -> typing.Tuple[ast.Name, ast.ClassDef]:
	scannerEnumClassAST = ast.ClassDef(
		name=name,
		bases=[ast.Name("IntEnum")],
		keywords=(),
		body=[
			ast.Assign(
				targets=[ast.Name(eofSymbolEnumMemberName)],
				value=ast.Constant(value=0, kind=None),
				type_comment=None,
			),
			ast.Assign(
				targets=[ast.Name(invalidSymbolEnumMemberName)],
				value=ast.Num(table.noSym.n),
				type_comment=None,
			),
		],
		decorator_list=(),
	)

	scannerEnumClassAST.body.extend(GenTokens(table, withNames))
	scannerEnumClassAST.body.extend(GenPragmas(table, withNames))
	return ast.Name(name), scannerEnumClassAST


def genClassStub(name: str, baseClassNameAST: ast.AST) -> ast.ClassDef:
	return ast.ClassDef(
		name=name,
		bases=[baseClassNameAST],
		keywords=(),
		body=[
			ast.Assign(targets=[ast.Name("__slots__")], value=ast.Tuple(elts=()), type_comment=None),
			ast.FunctionDef(
				name="__init__",
				args=ast.arguments(
					posonlyargs=(),
					args=[selfArgAST],
					vararg=ast.arg(arg="args", annotation=None, type_comment=None),
					kwonlyargs=(),
					kw_defaults=[],
					kwarg=ast.arg(arg="kwargs", annotation=None, type_comment=None),
					defaults=[],
				),
				body=[
					ast.Expr(
						value=ast.Str("This ctor is mandatory, don't delete it: otherwise self.__class__.ENUM will be None"),
					),
					ast.Expr(
						value=ast.Call(
							func=ast.Attribute(
								value=ast.Call(func=ast.Name("super"), args=(), keywords=()), attr="__init__",
							),
							args=[ast.Starred(value=ast.Name("args"))],
							keywords=[ast.keyword(arg=None, value=ast.Name("kwargs"))],
						)
					),
				],
				decorator_list=[
					ast.Call(
						func=ast.Name("wraps"),
						args=[ast.Attribute(value=baseClassNameAST, attr="__init__")],
						keywords=(),
					)
				],
				returns=None,
				type_comment=None,
			),
		],
		decorator_list=(),
	)


def GenCodePragmas(table: "Tab", name: str = "pragmas") -> ast.FunctionDef:
	body = []
	for sym in table.pragmas:
		body.append(ast.If(
			test=genSelfLaKindComp(printTermName(sym)),
			body=[
				*CopySourcePart(sym.semPos, True),
			],
			orelse=[],
		))

	if not body:
		body.append(ast.Pass())

	return ast.FunctionDef(
		name=name,
		args=ast.arguments(
			posonlyargs=[],
			args=[selfArgAST],
			vararg=None,
			kwonlyargs=[],
			kw_defaults=[],
			kwarg=None,
			defaults=[],
		),
		body=body,
		decorator_list=[],
		returns=noneAST,
		type_comment=None,
	)
