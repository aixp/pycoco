__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code


from enum import IntEnum

from CoCoRuntime.errors import Errors


class Symbol:
	__slots__ = ("n", "name", "line", "symName", "semPos", "attrs", "returnAttrs")

	nTyp = ("\t ", "t   ", "pr  ", "nt  ")

	def __init__(self, name: str, line: int, errors: Errors) -> None:
		assert isinstance(name, str)
		assert isinstance(line, int)
		self.n = 0  # symbol number
		self.name = 0  # symbol name
		self.line = 0  # source text line number of item in this node
		self.symName = None  # str,   symbolic name /* pdt */
		self.semPos = None  # Position,   pr: pos of semantic action in source text (or None)
		self.attrs = []
		self.returnAttrs = []

		if len(name) == 2 and name[0] == '"':
			errors.storeError(-1, -1, "empty token not allowed")
			name = "???"

		self.name = name
		self.line = line

	def compareTo(self, x):
		assert isinstance(x, Symbol)
		return self.name.__cmp__(x.name)


class SymbolTokensKinds(IntEnum):
	fixedToken = 0  # e.g. 'a' ('b' | 'c') (structure of literals)
	classToken = 1  # e.g. digit {digit}   (at least one char class)
	litToken = 2  # e.g. "while"
	classLitToken = 3  # e.g. letter {letter} but without literals that have the same structure


class SymWithTokenKind(Symbol):
	__slots__ = ("tokenKind",)

	def __init__(self, name: str, line: int, errors: Errors) -> None:
		super().__init__(name, line, errors)
		self.tokenKind = 0  # t:  token kind (fixedToken, classToken, ...)


class SymTerminal(SymWithTokenKind):
	__slots__ = ()

	def __init__(self, table: "Tab", name: str, line: int, errors: Errors) -> None:
		super().__init__(name, line, errors)
		self.n = len(table.terminals)
		table.terminals.append(self)


class SymPragma(SymWithTokenKind):
	__slots__ = ()

	def __init__(self, table: "Tab", name: str, line: int, errors: Errors) -> None:
		super().__init__(name, line, errors)
		table.pragmas.append(self)


class SymNonTerminal(Symbol):
	__slots__ = ("graph", "deletable", "firstReady", "first", "follow", "nts", "n")

	def __init__(self, table: "Tab", name: str, line: int, errors: Errors) -> None:
		super().__init__(name, line, errors)
		self.graph = None  # Node,  nt: to first node of syntax graph
		self.deletable = False  # nt: true if nonterminal is deletable
		self.firstReady = False  # nt: true if terminal start symbols have already been computed
		self.first = None  # set,   nt: terminal start symbols
		self.follow = None  # set,   nt: terminal followers
		self.nts = None  # set,   nt: nonterminals whose followers have to be added to this sym
		self.n = len(table.nonterminals)
		table.nonterminals.append(self)

	def __repr__(self):
		return self.__class__.__name__ + "<" + ", ".join(k + "=" + repr(getattr(self, k)) for k in ("name", "symName", "attrs", "returnAttrs")) + ">"
