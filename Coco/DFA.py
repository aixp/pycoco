__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code

import copy
import typing

from CoCoRuntime.errors import Errors

from .actions import Action, CharAct, CharClassAct, Melted, State, Target, TransitionCode
from .CharClass import CharClassStorage
from .charUtils import ReportCh, Unescape
from .defaults import INDENT
from .nodes import Node, NodeAlphabet, NodeAlternative, NodeCharacter, NodeCharClass, NodeIteration, NodeOption
from .symbols import Symbol, SymbolTokensKinds, SymTerminal
from .Trace import Trace


class DFA:
	"""Trying to separate canner generator from DFA"""

	__slots__ = ("gen", "fram", "maxStates", "lastSimState", "curSy", "curGraph", "trace", "srcName", "srcDir", "outDir", "firstState", "lastState", "ignoreCase", "dirtyDFA", "hasCtxMoves", "meltedListHead", "commentsListHead", "lastStateIdNo", "charClassStorage")

	EOF = -1
	CR = "\r"
	LF = "\n"

	# ---------- State handling
	def NewState(self) -> State:
		self.lastStateIdNo += 1
		s = State(self.lastStateIdNo, dfa=self)  # State
		if self.firstState is None:
			self.firstState = s
		else:
			self.lastState.next = s
		self.lastState = s
		return s

	def NewTransition(self, frm: State, to: State, typ: typing.Type[Action], sym: typing.Union[int, str], tc: int, errors: Errors) -> None:
		assert isinstance(frm, State)
		assert isinstance(to, State)
		assert issubclass(typ, Action), typ
		assert isinstance(sym, (int, str))
		assert isinstance(tc, int)
		if to == self.firstState:
			errors.storeError(-1, -1, "token must not start with an iteration")
		if isinstance(sym, str):
			sym = ord(sym)
		t = Target(to)
		a = typ(sym, tc, dfa=self)
		a.target = t
		frm.AddAction(a)
		if typ is CharClassAct:
			self.curSy.tokenKind = SymbolTokensKinds.classToken

	def CombineShifts(self) -> None:
		state = self.firstState
		limit = 100
		i = 0
		while state is not None:
			a = state.firstAction
			while a is not None:
				b = a.next
				while b is not None:
					if a.target.state == b.target.state and a.tc == b.tc:
						seta = a.Symbols()
						setb = b.Symbols()
						seta |= setb
						a.ShiftWith(seta)
						c = b
						b = b.next
						state.DetachAction(c)
					else:
						b = b.next
				a = a.next
			state = state.next
			if i > limit:
				raise Exception()
			i += 1

	def FindUsedStates(self, state: State, used: typing.Set[int]) -> None:
		assert isinstance(state, State)
		assert isinstance(used, set)
		if state.nr in used:
			return
		used.add(state.nr)
		a = state.firstAction
		while a is not None:
			self.FindUsedStates(a.target.state, used)
			a = a.next

	@staticmethod
	def _iterateStates(firstState: State) -> typing.Iterator[State]:
		"""Iterates fucking states list"""
		state = firstState
		while state is not None:
			yield state
			state = state.next

	def DeleteRedundantStates(self, reorderForLUT: bool = True) -> None:
		newState = [None for x in range(self.lastStateIdNo + 1)]
		used = set()
		self.FindUsedStates(self.firstState, used)

		# combine equal final states
		for s1 in self.__class__._iterateStates(self.firstState.next):
			# self.firstState cannot be final
			if (s1.nr in used) and (s1.endOf is not None) and (s1.firstAction is None) and not s1.ctx:
				s2 = s1.next
				while s2 is not None:
					nots2_ctx = 1 if not s2.ctx else 0
					if (s2.nr in used) and s1.endOf == s2.endOf and (s2.firstAction is None) & nots2_ctx:
						used.discard(s2.nr)
						newState[s2.nr] = s1
					s2 = s2.next

		for state in self.__class__._iterateStates(self.firstState):
			if state.nr in used:
				a = state.firstAction
				while a is not None:
					if a.target.state.nr not in used:
						a.target.state = newState[a.target.state.nr]
					a = a.next

		# delete unused states and renumber them to allow to use a look-up table in the generated parser for some of states
		lastState = self.firstState
		stateNewIdNo = 0  # self.firstState has number 0
		lastState = self.firstState
		assert lastState.nr == stateNewIdNo
		stateNewIdNo += 1

		nonFinalStates = []  # will go through if condition

		# chaining final states
		for state in self.__class__._iterateStates(self.firstState.next):
			if state.nr in used:
				if state.isTrivialFinal or not reorderForLUT:
					state.nr = stateNewIdNo
					stateNewIdNo += 1
					lastState.next = state
					lastState = state
				else:
					nonFinalStates.append(state)  # deferring
					lastState.next = state.next
			else:
				lastState.next = state.next

		for state in nonFinalStates:
			lastState.next = state
			state.nr = stateNewIdNo
			stateNewIdNo += 1
			lastState = state

		lastState.next = None

		self.lastState = lastState
		self.lastStateIdNo = stateNewIdNo

	def TheState(self, p: typing.Optional[Node]) -> State:
		assert isinstance(p, Node) or (p is None)
		if p is None:
			state = self.NewState()
			state.endOf = self.curSy
			return state
		return p.state

	def Step(self, frm: State, p: typing.Optional[Node], stepped: typing.Set[int], errors: Errors) -> None:
		assert isinstance(frm, State)
		assert isinstance(p, Node) or (p is None)
		assert isinstance(stepped, set)
		if p is None:
			return
		stepped.add(p.n)
		if isinstance(p, NodeAlphabet):
			if isinstance(p, NodeCharClass):
				typ = CharClassAct
			elif isinstance(p, NodeCharacter):
				typ = CharAct
			else:
				typ = Action

			self.NewTransition(frm, self.TheState(p.next), typ, p.val, p.code, errors)
		elif isinstance(p, NodeAlternative):
			self.Step(frm, p.sub, stepped, errors)
			self.Step(frm, p.down, stepped, errors)
		elif isinstance(p, (NodeIteration, NodeOption)):
			if (p.next is not None) and (p.next.n not in stepped):
				self.Step(frm, p.next, stepped, errors)
			self.Step(frm, p.sub, stepped, errors)

	def NumberNodes(self, p: typing.Optional[Node], state: typing.Optional[State]) -> None:
		"""Assigns a state n.state to every node n. There will be a transition
		from n.state to n.next.state triggered by n.val. All nodes in an
		alternative chain are represented by the same state."""
		assert isinstance(p, Node) or (p is None)
		assert isinstance(state, State) or (state is None)
		if p is None:
			return
		if p.state is not None:
			return
		if state is None:
			state = self.NewState()
		p.state = state
		if Node.DelGraph(p):
			state.endOf = self.curSy
		if isinstance(p, NodeAlphabet):
			self.NumberNodes(p.next, None)
		elif isinstance(p, NodeOption):
			self.NumberNodes(p.next, None)
			self.NumberNodes(p.sub, state)
		elif isinstance(p, NodeIteration):
			self.NumberNodes(p.next, state)
			self.NumberNodes(p.sub, state)
		elif isinstance(p, NodeAlternative):
			self.NumberNodes(p.sub, state)
			self.NumberNodes(p.down, state)

	def FindTrans(self, p: typing.Optional[Node], start: bool, marked: typing.Set[int], errors: Errors) -> None:
		assert isinstance(p, Node) or (p is None)
		assert isinstance(start, bool)
		assert isinstance(marked, set)
		if (p is None) or (p.n in marked):
			return
		marked.add(p.n)
		if start:
			self.Step(p.state, p, set(), errors)  # / start of group of equally numbered nodes
		if isinstance(p, NodeAlphabet):
			self.FindTrans(p.next, True, marked, errors)
		elif isinstance(p, NodeOption):
			self.FindTrans(p.next, True, marked, errors)
			self.FindTrans(p.sub, False, marked, errors)
		elif isinstance(p, NodeIteration):
			self.FindTrans(p.next, False, marked, errors)
			self.FindTrans(p.sub, False, marked, errors)
		elif isinstance(p, NodeAlternative):
			self.FindTrans(p.sub, False, marked, errors)
			self.FindTrans(p.down, False, marked, errors)

	def ConvertToStates(self, p: Node, sym: Symbol, errors: Errors) -> None:
		assert isinstance(p, Node), repr(p)
		assert isinstance(sym, Symbol)
		self.curGraph = p
		self.curSy = sym
		if Node.DelGraph(self.curGraph):
			errors.storeError(-1, -1, "token might be empty")
		self.NumberNodes(self.curGraph, self.firstState)
		self.FindTrans(self.curGraph, True, set(), errors)

	def MatchLiteral(self, s: str, sym: SymTerminal, errors: Errors) -> None:
		"""match string against current automaton; store it either as a
		fixedToken or as a litToken"""
		assert isinstance(sym, Symbol)
		assert isinstance(s, str)
		s = Unescape(s[1:-1], errors)
		ln = len(s)
		state = self.firstState  # State
		a = None
		endedPrematurely = False
		for i in range(0, ln):  # try to match s against existing DFA
			a = state.TheAction(s[i], self.charClassStorage)
			if a is None:
				endedPrematurely = True
				break
			state = a.target.state
		if not endedPrematurely:
			i = ln
		# if s was not totally consumed or leads to a non-final state => make new DFA from it
		if (i != ln) or (state.endOf is None):
			state = self.firstState
			i = 0
			a = None
			self.dirtyDFA = True
		while i < ln:  # make new DFA for s[i..len-1]
			to = self.NewState()  # State
			self.NewTransition(state, to, CharAct, s[i], TransitionCode.normalTrans, errors)
			state = to
			i += 1
		matchedSym = state.endOf  # Symbol
		if state.endOf is None:
			state.endOf = sym
		elif (matchedSym.tokenKind == SymbolTokensKinds.fixedToken) or (a is not None) and (a.tc == TransitionCode.contextTrans):
			# s matched a token with a fixed definition or a token with an appendix that will be cut off
			errors.storeError(-1, -1, "tokens " + sym.name + " and " + matchedSym.name + " cannot be distinguished")
		else:
			# matchedSym == classToken or classLitToken
			matchedSym.tokenKind = SymbolTokensKinds.classLitToken
			sym.tokenKind = SymbolTokensKinds.litToken

	def SplitActions(self, state: State, a: Action, b: Action) -> None:
		assert isinstance(state, State)
		assert isinstance(a, Action)
		assert isinstance(b, Action)
		seta = a.Symbols()
		setb = b.Symbols()
		if seta == setb:  # seta.equals(setb):
			a.AddTargets(b)
			state.DetachAction(b)
		elif seta >= setb:
			setc = copy.copy(seta)
			setc -= setb
			b.AddTargets(a)
			a.ShiftWith(setc)
		elif setb >= seta:
			setc = copy.copy(setb)
			setc -= seta
			a.AddTargets(b)
			b.ShiftWith(setc)
		else:
			setc = copy.copy(seta)
			setc &= setb
			seta -= setc
			setb -= setc
			a.ShiftWith(seta)
			b.ShiftWith(setb)
			c = Action(0, TransitionCode.normalTrans, self)  # typ and sym are set in ShiftWith
			c.AddTargets(a)
			c.AddTargets(b)
			c.ShiftWith(setc)
			state.AddAction(c)

	def Overlap(self, a: Action, b: Action) -> bool:
		assert isinstance(a, Action)
		assert isinstance(b, Action)
		if isinstance(a, CharAct):
			if isinstance(b, CharAct):
				return a.sym == b.sym

			setb = self.charClassStorage.Set(b.sym)
			return a.sym in setb

		seta = self.charClassStorage.Set(a.sym)
		if isinstance(b, CharAct):
			return b.sym in seta

		setb = self.charClassStorage.Set(b.sym)
		return len(seta & setb) > 0
		# return seta.intersects( setb )

	def MakeUnique(self, state: State) -> bool:
		assert isinstance(state, State)
		# return True if actions were split
		changed = False  # boolean
		a = state.firstAction
		while a is not None:
			b = a.next
			while b is not None:
				if self.Overlap(a, b):
					self.SplitActions(state, a, b)
					changed = True
				b = b.next
			a = a.next
		return changed

	def MeltStates(self, state: State, errors: Errors) -> None:
		assert isinstance(state, State)
		action = state.firstAction
		while action is not None:
			if action.target.next is not None:
				param = [None, None]
				ctx = action.GetTargetStates(self.meltedListHead, param, errors)
				targets = param[0]
				endOf = param[1]
				melt = Melted.StateWithSet(self.meltedListHead, targets)  # Melted
				if melt is None:
					s = self.NewState()
					s.endOf = endOf
					s.ctx = ctx
					targ = action.target
					while targ is not None:
						s.MeltWith(targ.state)
						targ = targ.next
					changed = self.MakeUnique(s)
					while changed:
						changed = self.MakeUnique(s)
					melt = self.meltedListHead = Melted(self.meltedListHead, targets, s)
				action.target.next = None
				action.target.state = melt.state
			action = action.next

	def FindCtxStates(self) -> None:
		state = self.firstState
		while state is not None:
			a = state.firstAction
			while a is not None:
				if a.tc == TransitionCode.contextTrans:
					a.target.state.ctx = True
				a = a.next
			state = state.next

	def MakeDeterministic(self, errors: Errors) -> None:
		self.lastSimState = self.lastState.nr
		self.maxStates = 2 * self.lastSimState  # heuristic for set size in Melted.set
		self.FindCtxStates()
		state = self.firstState
		while state is not None:
			changed = self.MakeUnique(state)
			while changed:
				changed = self.MakeUnique(state)
			state = state.next

		state = self.firstState
		while state is not None:
			self.MeltStates(state, errors)
			state = state.next
		self.DeleteRedundantStates()
		self.CombineShifts()

	def PrintStates(self):
		self.trace.WriteLine()
		self.trace.WriteLine("Automaton Trace:")
		self.trace.WriteLine("---------------")
		self.trace.WriteLine()
		self.trace.WriteLine("---------- states ----------")
		state = self.firstState
		while state is not None:
			first = True  # boolean
			if state.endOf is None:
				self.trace.Write(INDENT * 5)  # 5
			else:
				self.trace.Write("E(" + Node.Name(state.endOf.name) + ")", 12)
			self.trace.Write(str(state.nr) + ":", 4)
			if state.firstAction is None:
				self.trace.WriteLine()
			action = state.firstAction
			while action is not None:
				if first:
					self.trace.Write(" ")
					first = False
				else:
					self.trace.Write(INDENT * 6 + "  ")  # 6
				if isinstance(action, CharClassAct):
					self.trace.Write(self.charClassStorage[action.sym].name)
				else:
					self.trace.Write(ReportCh(action.sym), 3)
				targ = action.target
				while targ is not None:
					self.trace.Write(str(targ.state.nr), 4)
					targ = targ.next
				if action.tc == TransitionCode.contextTrans:
					self.trace.WriteLine(" context")
				else:
					self.trace.WriteLine()
				action = action.next
			state = state.next
		self.trace.WriteLine()
		self.trace.WriteLine("---------- character classes ----------")
		self.charClassStorage.WriteClasses(self.trace)

	def __init__(self, trace: Trace) -> None:
		self.maxStates = 0
		self.lastSimState = 0  # last non melted state
		self.gen = None  # PrintWriter,  generated scanner file
		self.curSy = None  # Symbol, current token to be recognized (in FindTrans)
		self.curGraph = None  # Node, start of graph for current token (in FindTrans)
		self.trace = trace
		self.firstState = None
		self.lastState = None  # State,  last allocated state
		self.lastStateIdNo = -1
		self.firstState = self.NewState()  # State
		self.meltedListHead = None  # Melted instance,   head of melted state list
		self.commentsListHead = None
		self.ignoreCase = False  # true if input should be treated case-insensitively
		self.dirtyDFA = False  # DFA may become nondeterministic in MatchedDFA
		self.hasCtxMoves = False  # DFA has context transitions
		self.charClassStorage = CharClassStorage()
