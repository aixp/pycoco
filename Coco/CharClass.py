"""Basics.py -- Some basic definitions"""

__copyright__ = """
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported from Java to Python by Ronald Longo
improved and refactored by KOLANICH

This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program.  If not, see <https://www.gnu.org/licenses/>.

As an exception, it is allowed to write an extension of Coco/R that is used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than Coco/R itself) does not fall under the GNU General Public License.
"""  # pylint: disable=duplicate-code


import typing

from .Trace import Trace

charSetSize = 256  # must be a multiple of 16


class CharClassStorage:
	__slots__ = ("storage", "dummyNo")

	def __init__(self):
		self.storage = []
		self.dummyNo = 0

	def spawn(self, name: str, s: typing.Set[typing.Union[int, str]]) -> None:
		n = len(self.storage)  # class number
		res = CharClass(n, name, s)
		self.storage.append(res)
		return res

	def getDummyName(self) -> str:
		name = "#" + hex(self.dummyNo)[2:]
		self.dummyNo += 1
		return name

	def spawnDummy(self, s: typing.Set[typing.Union[int, str]]):
		return self.spawn(self.getDummyName(), s)  # class with dummy name

	def __iter__(self):
		yield from self.storage

	def __getitem__(self, k) -> "CharClass":
		return self.storage[k]

	def Find(self, nameOrSet: typing.Union[typing.Set[int], str]) -> typing.Optional["CharClass"]:
		assert isinstance(nameOrSet, (str, set))
		if isinstance(nameOrSet, str):
			name = nameOrSet
			for c in self.storage:
				if c.name == name:
					return c
			return None

		s = nameOrSet
		for c in self.storage:
			if s == c.set:  # Sets.Equals(s, c.set):
				return c
		return None

	def Set(self, i: int) -> typing.Set[typing.Union[int, str]]:
		assert isinstance(i, int)
		return self.storage[i].set

	def WriteClasses(self, trace: Trace):
		for c in self.storage:
			trace.Write(str(c.name), -10)
			trace.Write(": ")
			c.WriteSet(trace)
			trace.WriteLine()
		trace.WriteLine()


class CharClass:
	__slots__ = ("n", "name", "set")

	def __init__(self, n: int, name: str, s: typing.Set[typing.Union[int, str]]) -> None:
		assert isinstance(name, str)
		assert isinstance(s, set)
		self.n = n
		self.name = name  # class name
		self.set = s  # set representing the class

	@staticmethod
	def Ch(ch):
		assert isinstance(ch, (str, int))
		if isinstance(ch, str):
			ch = ord(ch)
		if ch < ord(" ") or ch >= 127 or ch == ord("'") or ch == ord("\\"):
			return str(ch)
		return "'" + chr(ch) + "'"

	def WriteSet(self, trace: Trace):
		s = self.set.copy()
		try:
			s.remove("ANYCHAR")
		except KeyError:
			pass

		i = 0
		mx = max(s) + 1
		while i < mx:
			while i < mx and (i not in s):
				i += 1
			if i == mx:
				break
			j = i
			while i < mx and (i in s):
				i += 1
			if j < (i - 1):
				trace.Write(str(self.__class__.Ch(j)) + ".." + str(self.__class__.Ch(i - 1)) + " ")
			else:
				trace.Write(str(self.__class__.Ch(j) + " "))
